<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[flatten（扁平化）数组]]></title>
    <url>%2F2018%2F11%2F15%2Fflatten%EF%BC%88%E6%89%81%E5%B9%B3%E5%8C%96%EF%BC%89%E6%95%B0%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[前言顾名思义，扁平化就是将嵌套的多维数组变成一维数组的过程。今天将通过几种方式来实现数组的扁平化。 先定义这几种方法公用的一个数组 1const arr = [1, 2, [3, 4, [5, 6]]] 初级版初级版也通过两种方式来实现 第一种利用数组的concat方法 123456789101112function flatten(arr) &#123; let res = [] arr.map(element =&gt; &#123; if(Array.isArray(element)) &#123; res = res.concat(flatten(element)) &#125; else&#123; res.push(element) &#125; &#125;) return res&#125; 第二种使用参数默认值的方法 1234567891011function flatten(arr, res = []) &#123; for (let item of arr) &#123; if (Array.isArray(item)) &#123; res = flatten03(item, res) &#125; else&#123; res.push(item) &#125; &#125; return res&#125; 进阶版使用…三点运算符结合concat方法 123456function flatten(arr) &#123; while(arr.some(item =&gt; Array.isArray(item))) &#123; arr = [].concat(...arr) &#125; return arr&#125; 终极版Array.flat(n)是ES10扁平数组的api， n表示维度， n值为 Infinity时维度为无限大。我们的例子中是个三维数组，所以，写法为：1arr.flat(3)]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>flatten</tag>
        <tag>扁平化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中的修饰符sync]]></title>
    <url>%2F2018%2F04%2F10%2Fvue%E4%B8%AD%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6sync%2F</url>
    <content type="text"><![CDATA[为什么要使用sync在有些情况下，我们可能需要对一个 prop 进行“双向绑定”。不幸的是，真正的双向绑定会带来维护上的问题，因为子组件可以修改父组件，且在父组件和子组件都没有明显的改动来源。.sync 修饰符所提供的功能。当一个子组件改变了一个 prop 的值时，这个变化也会同步到父组件中所绑定。就是说我们可以直接在我们需要传的prop后面加上 .sync 使用方法和demo比如我需要绑定 mes,然后我在他后面加上.sync。1&lt;son :mes.sync="message"&gt;&lt;/son&gt;他会扩展成：1&lt;son :mes="message" @update:mes="val =&gt; message= val"&gt;&lt;/son&gt;举个栗子： 父组件代码：12345678910111213141516171819&lt;template&gt; &lt;div&gt; &lt;son :mes.sync='message'&gt; &lt;/son&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Son from './Son.vue'export default &#123; name: 'fathor', components: &#123; Son &#125;, data() &#123; return &#123; message: '我是父组件的数据' &#125; &#125;&lt;/script&gt; 子组件代码： 123456789101112131415161718&lt;template&gt; &lt;div&gt; &lt;input type="text" v-model="mes"/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default&#123; name:'son', props:&#123; mes: String &#125;, watch:&#123; mes(newValue)&#123; this.$emit('update:mes',newValue) &#125; &#125; &#125;&lt;/script&gt; 与自定义事件的区别看完上面的代码，你可能觉得这好像和“通过自定义事件（emit）从子组件向父组件中传递数据”是一样的。 其实并不一样， 两者有着父子组件关系上的不同， 下面我通过一行关键的代码证明它们的区别所在： 在我们使用.sync修饰符中， 自定义事件发生时候运行的响应表达式是： 1&lt;son :mes="message" @update:mes="val =&gt; message= val"&gt;&lt;/son&gt; 在“通过自定义事件从子组件向父组件中传递数据” 里，自定义事件发生时候运行的响应表达式是: 1&lt;son @eventYouDefined = "arg =&gt; functionYours(arg)"&gt;&lt;/son&gt; 对前者， 表达式 val =&gt; message = val意味着强制让父组件的数据等于子组件传递过来的数据， 这个时候，我们发现父子组件的地位是平等的。 父可以改变子（数据）， 子也可以改变父（数据）。 对后者， 你的functionYours是在父组件中定义的， 在这个函数里， 你可以对从子组件接受来的arg数据做任意的操作或处理， 决定权完全落在父组件中， 也就是： 父可以改变子（数据）， 但子不能直接改变父（数据）。 父中数据的变动只能由它自己决定。 参考资料Vue使用.sync 实现父子组件的双向绑定数据Vue中的父子组件通讯以及使用sync同步父子组件数据]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>sync修饰符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多台电脑操作hexo个人网站]]></title>
    <url>%2F2018%2F03%2F28%2F%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E6%93%8D%E4%BD%9Chexo%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[前言 最近换了个电脑，于是出现在新电脑上如何更新hexo个人网站的问题，网上各种方法，个人觉得还是有些不明白的地方，踩坑无数。最后终于成功，所以特此记下，也希望给其他人能有一些帮助。文章中用‘旧电脑’指代原来已经搭建好hexo的电脑，‘新电脑’指代即将要搭建hexo环境的电脑。 旧电脑上的操作准备工作首先确保自己已经使用hexo在github搭建好了自己的个人博客，github仓库中如下图显示： 对username.github.io仓库新建hexo分支，并克隆在Github的username.github.io（就是hexo网站的仓库）仓库上新建一个xxx（自己取名，我取名为hexo）分支，并切换到该分支，并在该仓库-&gt;Settings-&gt;Branches-&gt;Default branch中将默认分支设为xxx，save保存。 新建分支，并选中新建的分支，如下图： 设置新建的xxx分支为默认分支，如下图： 然后将该仓库克隆到本地，进入到本地的username.github.io文件目录。进入本地的username.github.io后，在当前目录使用git bash执行git branch命令查看当前所在分支，应为新建的分支xxx。 将本地博客的部署文件拷贝进username.github.io文件目录先将本地博客的部署文件（就是之前存放hexo项目的目录下的全部文件）全部拷贝进username.github.io文件目录中去。 接下来，进入username.github.io文件目录下，依次执行： git add . git commit -m ‘新电脑部署’（引号内容可改） git push 即可将博客的hexo部署环境提交到GitHub个人仓库的xxx分支。 此时部署到github的步骤就已经完成了。master分支和xxx分支各自保存着一个版本，master分支用于保存博客静态资源，提供博客页面供人访问；xxx分支用于备份博客部署文件，供自己修改和更新，两者在一个GitHub仓库内互不冲突，完美！ 新电脑上的操作到这一步，你的博客已经可以在其他电脑上进行同步的维护和更新了，方法很简单： 将新电脑生成的ssh key添加到GitHub账户上（生成并添加ssh key的方法自行百度，本文不做详细说明）。 在新电脑上克隆username.github.io仓库的xxx分支到本地，此时本地git仓库处于xxx分支.可以使用git branch查看当前分支。 切换到username.github.io目录，执行npm install(由于仓库有一个.gitignore文件，里面默认是忽略掉node_modules文件夹的，也就是说仓库的hexo分支并没有存储该目录，所以需要install下) 在新电脑上安装hexo命令1$ npm install -g hexo-cli 新旧电脑更新网站的方法首先注意一点：每次换电脑进行博客更新时，不管上次在其他电脑有没有更新，最好先git pull，防止冲突，这是一个好习惯。然后，依次执行以下步骤： 编辑、撰写文章或其他博客更新改动，就是你要对博客进行的修改，或新增文章。 依次执行git add .、git commit -m ‘在新电脑上提交新文章’（引号内容可改）、git push指令，保证xxx分支版本为最新版本。 依次执行hexo g,hexo d指令（执行之后，过几分钟如果网站上的内容没有更新，在hexo g之前，可能需要执行hexo clean），完成后就会发现，最新改动已经更新到master分支了，两个分支互不干扰！ 到此，就可以在多台电脑上更新个人网站啦！如有疑问，欢迎留言！ 参考资料利用Hexo在多台电脑上提交和更新博客]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Vue中的计算属性computed]]></title>
    <url>%2F2018%2F03%2F12%2F%E5%85%B3%E4%BA%8EVue%E4%B8%AD%E7%9A%84%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7computed%2F</url>
    <content type="text"><![CDATA[为什么要使用计算属性（computed）我们都知道，在Vue中，对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。看看代码:1234567&#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? &apos;YES&apos; : &apos;NO&apos; &#125;&#125;&#123;&#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125;&lt;div v-bind:id=&quot;&apos;list-&apos; + id&quot;&gt;&lt;/div&gt; 这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含单个表达式，所以下面的例子都不会生效。 1234567&lt;!-- 这是语句，不是表达式 --&gt;&#123;&#123; var a = 1 &#125;&#125;&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125; 模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。例如： 123&lt;div id=&quot;example&quot;&gt; &#123;&#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125;&lt;/div&gt; 在这个地方，模板不再是简单的声明式逻辑。你必须看一段时间才能意识到，这里是想要显示变量 message 的翻转字符串。当你想要在模板中多次引用此处的翻转字符串时，就会更加难以处理。所以，对于任何复杂逻辑，你都应当使用计算属性。一个简单的例子：html： 1234&lt;div id=&quot;example&quot;&gt; &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt; &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;&lt;/div&gt; js： 12345678910111213var vm = new Vue(&#123; el: &apos;#example&apos;, data: &#123; message: &apos;Hello&apos; &#125;, computed: &#123; // 计算属性的 getter reversedMessage: function () &#123; // `this` 指向 vm 实例 return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125; &#125;&#125;) 结果： Original message: “Hello”Computed reversed message: “olleH” 这里我们声明了一个计算属性 reversedMessage。我们提供的函数将用作属性 vm.reversedMessage的 getter 函数： 123console.log(vm.reversedMessage) // =&gt; &apos;olleH&apos;vm.message = &apos;Goodbye&apos;console.log(vm.reversedMessage) // =&gt; &apos;eybdooG&apos; 你可以打开浏览器的控制台，自行修改例子中的 vm。vm.reversedMessage 的值始终取决于 vm.message 的值。 你可以像绑定普通属性一样在模板中绑定计算属性。Vue 知道 vm.reversedMessage 依赖于 vm.message，因此当 vm.message 发生改变时，所有依赖 vm.reversedMessage 的绑定也会更新。而且最妙的是我们已经以声明的方式创建了这种依赖关系：计算属性的 getter 函数是没有副作用 (side effect)的，这使它更易于测试和理解。 计算属性(computed) 与方法（methods）的区别你可能已经注意到我们可以通过在表达式中调用方法来达到同样的效果： html：1&lt;p&gt;Reversed message: &quot;&#123;&#123; reversedMessage() &#125;&#125;&quot;&lt;/p&gt; js：123456// 在组件中methods: &#123; reversedMessage: function () &#123; return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125; 我们可以将同一函数定义为一个方法（methods）而不是一个计算属性（computed）。两种方式的最终结果确实是完全相同的。然而， 不同的是计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。 这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。 这也同样意味着下面的计算属性将不再更新，因为 Date.now() 不是响应式依赖：12345computed: &#123; now: function () &#123; return Date.now() &#125;&#125; 相比之下，每当触发重新渲染时，调用方法（methods）将总会再次执行函数。 我们为什么需要缓存？假设我们有一个性能开销比较大的的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法（methods）来替代。 计算属性(computed)与侦听属性（watch）Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性（watch）。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch——特别是如果你之前使用过 AngularJS。然而，通常更好的做法是使用计算属性（computed）而不是命令式的 watch 回调。细想一下这个例子： html：1&lt;div id=&quot;demo&quot;&gt;&#123;&#123; fullName &#125;&#125;&lt;/div&gt; js：12345678910111213141516var vm = new Vue(&#123; el: &apos;#demo&apos;, data: &#123; firstName: &apos;Foo&apos;, lastName: &apos;Bar&apos;, fullName: &apos;Foo Bar&apos; &#125;, watch: &#123; firstName: function (val) &#123; this.fullName = val + &apos; &apos; + this.lastName &#125;, lastName: function (val) &#123; this.fullName = this.firstName + &apos; &apos; + val &#125; &#125;&#125;) 上面代码是命令式且重复的。将它与计算属性（computed）的版本进行比较：123456789101112var vm = new Vue(&#123; el: &apos;#demo&apos;, data: &#123; firstName: &apos;Foo&apos;, lastName: &apos;Bar&apos; &#125;, computed: &#123; fullName: function () &#123; return this.firstName + &apos; &apos; + this.lastName &#125; &#125;&#125;) 是不是好了很多呢？ 计算属性的setter计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter ：12345678910111213141516// ...computed: &#123; fullName: &#123; // getter get: function () &#123; return this.firstName + &apos; &apos; + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(&apos; &apos;) this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125;// ... 现在再运行 vm.fullName = ‘John Doe’ 时，setter 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新。 参考资料vue官网]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>computed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[v-if和v-show的使用和区别]]></title>
    <url>%2F2018%2F02%2F23%2Fv-if%E5%92%8Cv-show%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[前言 专门记一篇关于vue条件渲染的文章似乎没有必要，刚开始也没打算记。但在应用过程中有时会有点迷惑，什么时候用v-if，什么时候用v-show，这两者有什么区别？所以，还是决定记一下，虽然大部分都是官网的介绍，但俗话说，眼过千变不如手过一遍。所以，记此篇。 v-if在字符串模板中，比如 Handlebars，我们得像这样写一个条件块：html代码：1234&lt;!-- Handlebars 模板 --&gt;&#123;&#123;#if ok&#125;&#125; &lt;h1&gt;Yes&lt;/h1&gt;&#123;&#123;/if&#125;&#125; 在 Vue 中，我们使用 v-if 指令实现同样的功能：html代码：1&lt;h1 v-if=&quot;ok&quot;&gt;Yes&lt;/h1&gt; 也可以用 v-else 添加一个“else 块”：html代码：12&lt;h1 v-if=&quot;ok&quot;&gt;Yes&lt;/h1&gt;&lt;h1 v-else&gt;No&lt;/h1&gt; 在 template 元素上使用 v-if 条件渲染分组因为 v-if是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个 template 元素当做不可见的包裹元素，并在上面使用 v-if。最终的渲染结果将不包含 template 元素。 12345&lt;template v-if=&quot;ok&quot;&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;p&gt;Paragraph 1&lt;/p&gt; &lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/template&gt; v-else你可以使用 v-else 指令来表示 v-if 的“else 块”： 123456&lt;div v-if=&quot;Math.random() &gt; 0.5&quot;&gt; Now you see me&lt;/div&gt;&lt;div v-else&gt; Now you don&apos;t&lt;/div&gt; v-else 元素必须紧跟在带 v-if 或者 v-else-if 的元素的后面，否则它将不会被识别。 v-else-ifv-else-if，顾名思义，充当 v-if 的“else-if 块”，可以连续使用：123456789101112&lt;div v-if=&quot;type === &apos;A&apos;&quot;&gt; A&lt;/div&gt;&lt;div v-else-if=&quot;type === &apos;B&apos;&quot;&gt; B&lt;/div&gt;&lt;div v-else-if=&quot;type === &apos;C&apos;&quot;&gt; C&lt;/div&gt;&lt;div v-else&gt; Not A/B/C&lt;/div&gt; 类似于 v-else，v-else-if 也 必须紧跟 在带 v-if 或者 v-else-if 的元素之后! 用 key 管理可复用的元素Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使Vue变得非常快之外，还有其它一些好处。例如，如果你允许用户在不同的登录方式之间切换：html代码：12345678&lt;template v-if=&quot;loginType === &apos;username&apos;&quot;&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder=&quot;Enter your username&quot;&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder=&quot;Enter your email address&quot;&gt;&lt;/template&gt; 那么在上面的代码中切换 loginType 将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，input标签不会被替换掉——仅仅是替换了它的 placeholder。 这样也不总是符合实际需求，所以 Vue 为你提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 key 属性即可：12345678&lt;template v-if=&quot;loginType === &apos;username&apos;&quot;&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder=&quot;Enter your username&quot; key=&quot;username-input&quot;&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder=&quot;Enter your email address&quot; key=&quot;email-input&quot;&gt;&lt;/template&gt; 现在，每次切换时，输入框都将被重新渲染。 注意，label元素仍然会被高效地复用，因为它们没有添加 key 属性。 v-show另一个用于根据条件展示元素的选项是 v-show 指令。用法大致一样：1&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt; 不同的是带有v-show的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS 属性 display。 注意，v-show 不支持 template 元素，也不支持 v-else。 v-if vs v-showv-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。 v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。 一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>v-if</tag>
        <tag>v-show</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[for in和for of的区别]]></title>
    <url>%2F2017%2F08%2F29%2Ffor-in%E5%92%8Cfor-of%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[遍历数组以前我们遍历数组通常使用for循环，例如： 1234var arr = [&apos;apple&apos;, &apos;orange&apos;, &apos;banana&apos;]for (var i = 0; i &lt; arr.length; i++) &#123; console.log(arr[i])&#125; ES5的话也可以使用forEach，例如： 1234var arr = [&apos;apple&apos;, &apos;orange&apos;, &apos;banana&apos;]arr.forEach(function(val) &#123; console.log(val)&#125;) 但是使用forEach遍历数组的话，使用break不能中断循环，使用return也不能返回到外层函数。 ES5具有遍历数组功能的还有map、filter、some、every等，只不过他们的返回结果不一样。 使用for in也可以遍历数组，例如： 12345678Array.prototype.method = function()&#123; console.log(this.length)&#125;var arr = [&apos;apple&apos;, &apos;orange&apos;, &apos;banana&apos;]arr.name = &quot;数组&quot;for (var index in arr) &#123; console.log(arr[index])&#125; 打印的结果： 1234567appleorangebanana数组ƒ ()&#123; console.log(this.length)&#125; 由打印的结果可以看出，使用for in会遍历数组所有的可枚举属性，包括原型。例如上面栗子中的原型方法method和name属性。 除此之外，使用for in遍历数组还会存在以下问题： index索引为字符串型数字，不能直接进行几何运算 遍历顺序有可能不是按照实际数组的内部顺序 所以for in更适合遍历对象，不要使用for in遍历数组。 那么除了使用for循环，如何更简单的正确的遍历数组达到我们的期望呢（即不遍历method和name），ES6中的for of是个很好的选择。 123456789Array.prototype.method = function()&#123; console.log(this.length)&#125;const arr = [&apos;apple&apos;, &apos;orange&apos;, &apos;banana&apos;]arr.name=&quot;数组&quot;;for (var value of arr) &#123; console.log(value);&#125;// &apos;apple&apos;, &apos;orange&apos;, &apos;banana&apos; 打印结果可以看出，for of遍历的只是数组内的元素，而不包括数组的原型属性method和索引name。 遍历对象通常用for in来遍历对象的键名，例如：1234567891011Object.prototype.method = function() &#123; console.log(this);&#125;var myObject=&#123; a:1, b:2, c:3&#125;for (var key in myObject) &#123; console.log(key)&#125; for in可以遍历到myObject的原型方法method。如果不想遍历原型方法和属性的话，可以在循环内部判断下,hasOwnPropery方法可以判断某属性是否是该对象的实例属性：12345for (var key in myObject) &#123; if（myObject.hasOwnProperty(key))&#123; console.log(key); &#125;&#125; 或者可以通过ES5的Object.keys(myObject)获取对象的实例属性组成的数组，不包括原型方法和属性。 123Object.keys(myObject).forEach(function(key) &#123; console.log(myObject[key])&#125;) 总结 for in遍历的是数组的索引（即键名），而for of遍历的是数组元素值。 for in更适合遍历对象，for of更适合遍历数组。]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>for of</tag>
        <tag>for in</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js常见算法题]]></title>
    <url>%2F2017%2F08%2F16%2Fjs%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[判断一个单词是否是回文12345var str = 'helloolleh';function checkPalindrom(str) &#123; return str == str.split('').reverse().join('');&#125;console.log(checkPalindrom(str));//true 去掉一组整型数组重复的值1let arr = [1, 13, 24, 11, 11, 14, 1, 2]; 第一种方法：Object方法。主要考察个人对Object的使用，利用key来进行筛选。123456789101112let unique = function (arr) &#123; let hashTable = &#123;&#125;; let data = []; for (let i = 0, l = arr.length; i &lt; l; i++) &#123; if (!hashTable[arr[i]]) &#123; hashTable[arr[i]] = true; data.push(arr[i]); &#125; &#125; return data;&#125; console.log(unique(arr));//[1,13,24,11,14,2] 第二种方法：Set方法12let newArr = Array.from(new Set(arr));console.log(newArr);//[1,13,24,11,14,2] 第三种方法：indexOf方法12345678910let unique02 = function(arr)&#123; let newArr = [arr[0]]; for(let i = 1;i &lt; arr.length;i ++)&#123; if(newArr.indexOf(arr[i]) == -1)&#123; newArr.push(arr[i]); &#125; &#125; return newArr;&#125;console.log(unique02(arr));//[1,13,24,11,14,2] 统计一个字符串出现最多的字母123456789101112131415161718192021222324let str = 'afjghdfraaaasdenas';function findMaxDuplicateChar(str) &#123; if (str.length == 1) &#123; return str; &#125; let charObj = &#123;&#125;; for (let i = 0; i &lt; str.length; i++) &#123; if (!charObj[str.charAt(i)]) &#123; charObj[str.charAt(i)] = 1; &#125; else &#123; charObj[str.charAt(i)] += 1; &#125; &#125; let maxChar = '', maxValue = 1; for (var k in charObj) &#123; if (charObj[k] &gt;= maxValue) &#123; maxChar = k; maxValue = charObj[k]; &#125; &#125; return maxChar;&#125;console.log(findMaxDuplicateChar(str));//a 排序算法1let arr = ['a','d','c','b']; 第一种：冒泡排序12345678910111213141516function bubbleSort(arr)&#123; if (arr.length &lt;= 1) &#123; return arr; &#125; for(let i = 0;i &lt; arr.length-1;i ++)&#123; for(let j = i+1;j &lt; arr.length;j ++)&#123; if(arr[i] &gt; arr[j])&#123; let temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr;&#125;console.log(bubbleSort(arr));//['a','b','c','d'] 第二种：快速排序1234567891011121314151617function quickSort(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; let leftArr = []; let rightArr = []; let q = arr[0]; for (let i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &gt; q) &#123; rightArr.push(arr[i]); &#125; else &#123; leftArr.push(arr[i]); &#125; &#125; return [].concat(quickSort(leftArr), [q], quickSort(rightArr));&#125;console.log(quickSort(arr));//['a','b','c','d'] 随机生成指定长度的字符串1234567891011//参数n为要生成的字符串长度function randomString(n) &#123; let str = 'abcdefghijklmnopqrstuvwxyz9876543210'; let tmp = '', i = 0, l = str.length; for (i = 0; i &lt; n; i++) &#123; tmp += str.charAt(Math.floor(Math.random() * l)); &#125; return tmp;&#125; 找出正数组的最大差值12var arr = [10,5,11,7,8,9]; 很明显我们知道，最大差值肯定是一个数组中最大值与最小值的差。12345678910111213function getMaxProfit(arr) &#123; var minPrice = arr[0]; var maxProfit = 0; for (var i = 0; i &lt; arr.length; i++) &#123; var currentPrice = arr[i]; minPrice = Math.min(minPrice, currentPrice); var potentialProfit = currentPrice - minPrice; maxProfit = Math.max(maxProfit, potentialProfit); &#125; return maxProfit;&#125;console.log(getMaxProfit(arr));//6]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>js算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsonp解决跨域问题]]></title>
    <url>%2F2017%2F08%2F13%2Fjsonp%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[jsonp名字听上去挺高大上，实际只要理解了就是个矮穷矬。 jsonp原理利用script标签没有跨域限制的“漏洞”，来达到与第三方通讯的目的。 第三方产生的响应为json数据的包装（故称之为jsonp，即json padding）。 它的基本思想是，网页通过添加一个script元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。 首先，网页动态插入script元素，由它向跨源网址发出请求。 1234567891011121314function addScriptTag(src) &#123; var script = document.createElement(&apos;script&apos;); script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;); script.src = src; document.body.appendChild(script);&#125;window.onload = function () &#123; addScriptTag(&apos;http://example.com/ip?callback=foo&apos;);&#125;function foo(data) &#123; console.log(&apos;Your public IP address is: &apos; + data.ip);&#125;; 上面代码通过动态添加script元素，向服务器example.com发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于JSONP是必需的。服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。123foo(&#123; &quot;ip&quot;: &quot;8.8.8.8&quot;&#125;); 由于script元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用JSON.parse的步骤。 面试中的问题 知道 jsonp么？答：知道，可以实现跨域请求；答不知道：换别的话题。 为什么 ajax 不可以，但是 jsonp 可以实现跨域请求呢？答：因为 jsonp 是通过插入一个 script 标签，利用 script 可以跨域请求来实现的。换问题3；答：面试官傻逼，ajax 现在也可以使用 cors 来做跨域请求；换问题 2.5。答不知道：换问题 2.5。2.5 jsonp实现原理？答：通过创建一个 script 标签，将 src 设置为目标请求，插入到 dom 中，服务器接受该请求并返回数据，数据通常被包裹在回调钩子中；回答不知道：我自己解释 jsonp 的实现。 可以用 jsonp 发送 post 请求么？答：显然不行，看过支持 post 请求的 script 么？答不知道：反问，看过支持 post 请求的 script 么？ 参考 jsonp，还有那些发送跨域请求的途径？答：img link iframe 等元素都可以发送跨域请求呀！答不知道：反问img link iframe 等元素是不是也可以？ 参考资料浏览器同源政策及其规避方法jsonp为什么不支持post请求，寸志的回答]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>跨域</tag>
        <tag>jsonp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中的函数节流（throttle）和函数去抖（debounce）]]></title>
    <url>%2F2017%2F07%2F22%2Fjs%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%EF%BC%88throttle%EF%BC%89%E5%92%8C%E5%87%BD%E6%95%B0%E5%8E%BB%E6%8A%96%EF%BC%88debounce%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 在js中，我们经常会遇到这种情况，需要监听页面的scroll事件或者鼠标的mousemove事件等。由于这些事件在鼠标移动的过程中会被浏览器频繁的触发，会导致对应的事件也会被频繁的触发，这样就会造成很大的浏览器资源开销，而且好多中间的处理是不必要的，这样就会造成浏览器卡顿的现象。我们无法做到让浏览器不去触发对应的事件，但是可以做到让处理事件的方法执行频率减少（throttle）或者在执行动作完成后执行一次（debounce），从而减少对应的处理开销。 throttle和debounce的区别throttle指，在动作执行过程中，隔断时间触发一次事件，这样可以减少事件的方法执行的频率。debounce指只在动作结束后触发一次，把中间的处理函数全部过滤掉了，只执行规判定时间内的最后一个事件。 一般window的resize，input的keyup事件使用debounce；scroll、mousemove等事件使用throttle。 throttle的实现直接上代码 1234567891011121314//实现思路//两个参数：一个对应的处理函数,一个执行的频率//内部需要一个lastTime变量记录上一次执行的时间function throttle (func, wait) &#123; let lastTime = null // 为了避免每次调用lastTime都被清空，利用闭包返回一个function确保不声明全局变量也可以 return function () &#123; let now = new Date() // 如果上次执行的时间和这次触发的时间大于一个执行周期，则执行 if (now - lastTime - wait &gt; 0) &#123; func() lastTime = now &#125; &#125; &#125; 接下来就是调用了 12345let throttleRun = throttle(() =&gt; &#123; console.log(123)&#125;, 400);window.addEventListener('scroll', throttleRun) 这时候疯狂的滚动页面，会发现会400ms打印一个123，而没有节流的话会不断地打印。 但是到这里，我们的节流方法是不完善的，因为我们的方法没有获取事件发生时的this对象，而且由于我们的方法简单粗暴的通过判断这次触发的时间和上次执行时间的间隔来决定是否执行回调，这样就会造成最后一次触发无法执行，或者用户触发的间隔确实很短，也无法执行，造成了误杀，所以需要对方法进行完善。 123456789101112131415161718192021222324 function throttle(func, wait) &#123; let lastTime = null let timeout return function () &#123; let context = this; let now = new Date(); let arg = arguments; // 如果上次执行的时间和这次触发的时间大于一个执行周期，则执行 if (now - lastTime - wait &gt; 0) &#123; // 如果之前有了定时任务则清除 if (timeout) &#123; clearTimeout(timeout) timeout = null &#125; func.apply(context, arg) lastTime = now &#125; else if (!timeout) &#123; timeout = setTimeout(() =&gt; &#123; // 改变执行上下文环境 func.apply(context, arg) &#125;, wait) &#125; &#125;&#125; 这样我们的方法就相对完善了，调用方法和之前相同。 debounce的实现去抖的方法，和节流思路一致，但是只有在动作被判定结束后，方法才会得到执行。 1234567891011121314151617function debounce(method, delay) &#123; var timer = null; return function () &#123; var context = this, args = arguments; if(timer)&#123; clearTimeout(timer); timer = null; &#125; timer = setTimeout(function () &#123; method.apply(context, args); &#125;, delay); &#125;&#125;let debounceRun = debounce(() =&gt; &#123; console.log('123');&#125;, 600);window.addEventListener('resize', debounceRun); 调用方法和之前相同。 如有错误，欢迎指正！]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>throttle</tag>
        <tag>debounce</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCode好用的插件]]></title>
    <url>%2F2017%2F06%2F26%2FVScode%E5%A5%BD%E7%94%A8%E7%9A%84%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Open-In-Browser由于 VSCode 没有提供直接在浏览器中打开文件的内置界面，所以此插件在快捷菜单中添加了在默认浏览器查看文件选项，以及在客户端（Firefox，Chrome，IE）中打开命令面板选项。 vscode-icon让 VSCode 资源树目录加上图标，必备良品！ Path Intellisense自动路劲补全，默认不带这个功能的 beautifyBeautify css/sass/scss/lessreact-beautify格式化代码使用指南：按F1,然后输入bea—&gt;选择你要格式的文件类型 js/css/html Bracket Pair Colorizer让括号拥有独立的颜色，易于区分。可以配合任意主题使用。 Auto Close Tag自动闭合HTML标签 Auto rename tag更改HTML/XML标签名时，自动更新相对应的开始标签或结束标签的标签名 Color Info这个便捷的插件，将为你提供你在 CSS 中使用颜色的相关信息。你只需在颜色上悬停光标，就可以预览色块中色彩模型的（HEX、 RGB、HSL 和 CMYK）相关信息了。 HTML Snippets超级实用且初级的 H5代码片段以及提示 HTML CSS Support让 html 标签上写class 智能提示当前项目所支持的样式 jQuery Code Snippetsjquery 重度患者必须品，废话不多说，上图： HTMLHinthtml代码检测 CSS Peek使用此插件，你可以追踪至样式表中 CSS 类和 ids 定义的地方。当你在 HTML 文件中右键单击选择器时，选择“ Go to Definition 和 Peek definition ”选项，它便会给你发送样式设置的 CSS 代码。 veturVUE —— 语法高亮、智能感知、Emmet等 VueHelperVUE —— snippet代码片段 filesize会在左下角显示文件大小，很不错 Debugger for ChromePreview按F1,输入open preview to the side 设置自动换行设置 – 用户设置 – 添加”editor.wordWrap”: “on”]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>VSCode插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查找数组中某个元素出现的所有下标]]></title>
    <url>%2F2017%2F06%2F12%2F%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0%E5%87%BA%E7%8E%B0%E7%9A%84%E6%89%80%E6%9C%89%E4%B8%8B%E6%A0%87%2F</url>
    <content type="text"><![CDATA[前言前几天在工作中遇到一个需求，需要在一个url中截取第二个’/‘开始后面的字符，于是就需要获取到第二个’/‘的小标。如何在字符串中获取某个字符第n次出现的下标呢？用此文记录一下。 获取字符串中某字符第n次出现的下标123456789function find(str, cha, num) &#123; let index = str.indexOf(cha) for (let i = 0;i &lt; num; i ++) &#123; index = str.indexOf(cha, index+1) // 第二个参数为查找的起始位置 &#125; return index&#125;var str = &apos;-a-b--c-f&apos;console.log(find(str,&apos;-&apos;, 2)) // 第三次出现的下标 查找数组中某个元素出现的所有下标1234567891011121314151617181920function find(arr, cha) &#123; const indexArr = [] let index = arr.indexOf(cha) // 第一种方法 // while (index !== -1) &#123; // indexArr.push(index) // index = arr.indexOf(cha, index + 1) // &#125; // 第二种方法 for (let i = 0; i &lt; arr.length; i ++) &#123; if (index === -1) break // 如果找不到，跳出循环 indexArr.push(index) index = arr.indexOf(cha, index + 1) &#125; return indexArr&#125;const arr = [&quot;Banana&quot;,&quot;Orange&quot;,&quot;Apple&quot;,&quot;Mango&quot;,&quot;Banana&quot;,&quot;Orange&quot;,&quot;Apple&quot;]console.log(find(arr, &apos;Banana&apos;)) // [0, 4]]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>下标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片懒加载的简单实现]]></title>
    <url>%2F2017%2F05%2F25%2F%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[为什么要使用懒加载在网页中，我们有时候需要展示多张图片。如果图片太多，页面的加载速度会慢很多，这样会非常影响用户体验。所以，在图片过多的页面，为了加速页面的加载进度，我们需要将页面中没出现在可视区域内的图片先不做加载，等图片滚动到可视区域内时，再把图片加载出来，这样对于页面的加载性能会有很大的提升。 懒加载的原理将页面中所有img标签的src统一设置为一张占位图进行占位，然后给每个img标签添加一个属性data-src（这个属性可以自定义）指向图片的真实地址。 当载入页面时，先把可视区域内的img标签的data-src属性值赋给src属性。然后监听滚动事件，当img标签出现在可视区域时，把data-src属性值赋给src属性。 这样，便实现了懒加载。 懒加载的实现直接上代码。 12345678910111213&lt;body&gt; &lt;img src="frngji01(3).png" data-src="http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg" alt=""&gt; &lt;img src="frngji01(3).png" data-src="http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg" alt=""&gt; &lt;img src="frngji01(3).png" data-src="http://ww1.sinaimg.cn/large/006y8mN6gw1fa7kaed2hpj30sg0l9q54.jpg" alt=""&gt; &lt;img src="frngji01(3).png" data-src="http://ww1.sinaimg.cn/large/006y8mN6gw1fa7kaed2hpj30sg0l9q54.jpg" alt=""&gt; &lt;img src="frngji01(3).png" data-src="http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg" alt=""&gt; &lt;img src="frngji01(3).png" data-src="http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg" alt=""&gt; &lt;img src="frngji01(3).png" data-src="http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg" alt=""&gt; &lt;img src="frngji01(3).png" data-src="http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg" alt=""&gt; &lt;img src="frngji01(3).png" data-src="http://ww1.sinaimg.cn/large/006y8mN6gw1fa7kaed2hpj30sg0l9q54.jpg" alt=""&gt; &lt;img src="frngji01(3).png" data-src="http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg" alt=""&gt; &lt;img src="frngji01(3).png" data-src="http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg" alt=""&gt;&lt;/body&gt; 上面为html部分，是一些图片。 接下来，我们给img标签加一些样式。 123456img &#123; display: block; margin-bottom: 50px; width: 400px; height: 400px; &#125; 现在，页面中就有一些一列排的占位图片。 接下来，就来实现懒加载。 123456789101112131415161718function lazyload()&#123; let n = 0; //存储图片加载到的位置，避免每次都从第一张图片开始遍历 return function () &#123; let num = document.getElementsByTagName('img').length,//获取图片的个数 img = document.getElementsByTagName("img"), seeHeight = document.documentElement.clientHeight || document.body.clientHeight, //可见区域高度 scrollTop = document.documentElement.scrollTop || document.body.scrollTop; //滚动条距离顶部高度 for (let i = n; i &lt; num; i++) &#123; //判断图片是否进入可视区域 if (img[i].offsetTop &lt; seeHeight + scrollTop) &#123; if (img[i].getAttribute("src") == "frngji01(3).png") &#123; img[i].src = img[i].getAttribute("data-src"); &#125; n = i + 1; &#125; &#125; &#125;&#125; 这样，我们就实现了懒加载的基本逻辑。接下来我们需要在页面刚开始加载时，就把可视区域的图片加载出来。 12let lazyInit = lazyload();lazyInit();//页面载入完毕加载可试区域内的图片 然后，我们监听页面的滚动事件。 1window.addEventListener('scroll', lazyInit); 但到这里，我们的懒加载是不完善的。在js中的函数节流（throttle）和函数去抖（debounce）中说过，当需要监听scroll事件时，我们一般会使用throttle节流方法。 接下来，我们就来完善一下我们的代码。 首先，先定义一个节流的函数。 12345678910111213141516171819202122232425function throttle(func, wait) &#123; // 为了避免每次调用lastTime都被清空，利用闭包返回一个function确保不声明全局变量也可以 let lastTime = null let timeout return function () &#123; let context = this; let now = new Date(); let arg = arguments; // 如果上次执行的时间和这次触发的时间大于一个执行周期，则执行 if (now - lastTime - wait &gt; 0) &#123; // 如果之前有了定时任务则清除 if (timeout) &#123; clearTimeout(timeout) timeout = null &#125; func.apply(context, arg) lastTime = now &#125; else if (!timeout) &#123; timeout = setTimeout(() =&gt; &#123; // 改变执行上下文环境 func.apply(context, arg) &#125;, wait) &#125; &#125;&#125; 然后，再调用节流的方法 1let lazyScroll = throttle(lazyInit, 800); 最后，我们修改scroll事件的回调方法为lazyScroll。 1window.addEventListener('scroll', lazyScroll); 到这里，我们就实现了一个简单的懒加载。 如有错误，欢迎指正！ 参考资料前端如何实现图片懒加载(lazyload) 提高用户体验]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>懒加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端点击（click）事件延迟问题的产生与解决方法]]></title>
    <url>%2F2017%2F05%2F13%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%82%B9%E5%87%BB%EF%BC%88click%EF%BC%89%E4%BA%8B%E4%BB%B6%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98%E7%9A%84%E4%BA%A7%E7%94%9F%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[为什么会存在300ms延迟？移动浏览器为什么会设置300毫秒的等待时间呢？这与双击缩放的方案有关。平时我们可能已经注意到了，双击缩放，即用手指在屏幕上快速点击两次，可以看到内容或者图片放大，再次双击，浏览器会将网页缩放至原始比例。 浏览器捕获第一次单击后，会先等待一段时间，如果在这段时间区间里用户未进行下一次点击，浏览器会做单击事件的处理。如果这段时间里用户进行了第二次单击操作，则浏览器会做缩放处理。这段时间就是移动端点击事件的300ms延迟。 如何避免延迟？方法一：禁止缩放1&lt;meta name = &quot;viewport&quot; content=&quot;user-scalable=no&quot; &gt; 使用这个方法是通过完全禁用缩放来达到目的，虽然大部分移动端能解决这个延迟问题，但是部分苹果手机还是不行。 方法二：fastclick.jsFastClick 是 FT Labs 专门为解决移动端浏览器 300 ms点击延迟问题所开发的一个轻量级的库。简而言之，FastClick 在检测到touchend事件的时候，会通过 DOM 自定义事件立即触发一个模拟click事件，并把浏览器在 300 ms之后真正触发的click事件阻止掉。使用方法如下： 第一步：在页面中引入fastclick.js文件； 第二步：在js文件中添加以下代码： 12345678910111213141516171819202122// 原生js写法if (&apos;addEventListener&apos; in document) &#123; document.addEventListener(&apos;DOMContentLoaded&apos;, function() &#123; // 参数可以是任意的dom元素，如果写document.body，说明会将document.body下面的所的元素都绑定fastclick FastClick.attach(documen.body) &#125;, false);&#125;// jQuery写法$(function() &#123; FastClick.attach(document.body);&#125;);// 在vue中的使用方法// 安装npm install fastclick -S// 引入import FastClick from &apos;fastclick&apos;// 使用FastClick.attach(document.body);]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>300ms延迟</tag>
        <tag>fastclick</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[元素宽高成比例自适应]]></title>
    <url>%2F2017%2F04%2F11%2F%E5%85%83%E7%B4%A0%E5%AE%BD%E9%AB%98%E6%88%90%E6%AF%94%E4%BE%8B%E8%87%AA%E9%80%82%E5%BA%94%2F</url>
    <content type="text"><![CDATA[前言在开发过程中，我们经常会遇到让元素的宽高成一定比例的情况。或者在使用轮播图时，如果我们只是靠图片撑开元素的高度，那图片未加载出来时，页面会出现抖动的情况。为了避免这种情况，我们就需要让容器宽高成一定比例，如果图片是600*300的尺寸，我们就需要让容器的宽高比为2:1。 第一种方式我们可以使容器的宽度为100%，但高度不能使用50%，因为元素的高度是根据父元素的高度为基数的，并不是宽度。那我们这时候就需要用一点小技巧了，我们知道元素的padding值都是以父元素的宽度为基数的。那我们就可以这样实现：123456div &#123; width: 100%; height: 0; // 防止内容撑开高度 padding-bottom: 50%; overflow:hidden;&#125; 其实代码很简单，主要是记录一下思路。 第二种方式还有另一种实现方式：使用vw，相对于视口的宽度，视口被均分为100单位的vw1234div&#123; width:100vw; height:50vw;&#125; 但是这种目前兼容性不是很好，所以如果需要兼容性好的话，还是使用第一种方法吧！]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>自适应</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[圣杯布局]]></title>
    <url>%2F2017%2F04%2F02%2F%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[前言 在上一篇实现了双飞翼布局，这篇来实现一下圣杯布局。圣杯布局和双飞翼实现的效果是一样的，都是三栏布局，两侧栏宽度固定，中间栏自适应并且能在浏览器中优先展示渲染。 圣杯布局废话不多说，直接上代码吧。 首先，先给出页面结构，在三栏外面套一个容器，如下代码：1234567&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;center col&quot;&gt;&lt;/div&gt; &lt;div class=&quot;left col&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right col&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 上面就是我们第一步的页面结构，把center写在第一个是为了实现在浏览器优先渲染。 然后，开始写样式，首先给三栏写上基本样式如下,高度都为400px：123456789101112131415.col&#123; height:400px;&#125;.center&#123; width:100%; background:red;&#125;.left&#123; width:200px; background:green;&#125;.right&#123; width:200px; background:blue;&#125; 到这里，我们三栏的基本样式就出来了。此时，三栏并不在一行，那块级元素怎么才能一行显示呢？那就是通过浮动。所以，我们再加上12345678910111213141516.col&#123; height: 400px; float: left;//新增&#125;.center&#123; width: 100%; background: red;&#125;.left&#123; width: 200px; background: green;&#125;.right&#123; width: 200px; background: blue;&#125; 这时候center的宽度是占满屏幕的，那这样才能让它在中间呢？这时给外层的container加上样式：123.container &#123; padding: 0 200px;&#125; 这时候，已经实现了三栏都在中间，但由于center宽度为100%，左右两栏被挤到了第二行，这时，就需要用上负边距来使三栏在同一行123456789101112131415161718192021.container &#123; padding: 0 200px;&#125;.col&#123; height: 400px; float: left;&#125;.center&#123; width: 100%; background: red;&#125;.left&#123; width: 200px; background: green; margin-left: -100%; // 新增&#125;.right&#123; width: 200px; background: blue; margin-left: -200px; // 新增&#125; 到这里，三栏已经在同一行了，但三栏现在都是在中间，怎么让左右两栏位于两侧呢？这时我们就需要给左右两栏加上相对定位来改变他们自身的位置：12345678910111213141516171819202122232425.container &#123; padding: 0 200px;&#125;.col&#123; height: 400px; float: left;&#125;.center&#123; width: 100%; background: red;&#125;.left&#123; width: 200px; background: green; margin-left: -100%; position: relative; // 新增 left: -200px; // 新增&#125;.right&#123; width: 200px; background: blue; margin-left: -200px; position: relative; // 新增 left: 200px; // 新增&#125; 至此，我们就实现了圣杯布局！]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>圣杯布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双飞翼布局]]></title>
    <url>%2F2017%2F04%2F01%2F%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[前言 双飞翼布局和圣杯布局，都是三栏布局，两侧栏宽度固定，中间栏自适应并且能在浏览器中优先展示渲染。它们实现的效果是一样的，差别在于其实现的思想。 既然了解了这两种布局的功能，接下来我们就来看看具体怎么实现吧。文章中的两种方式都是兼容目前所有的主流浏览器，包括IE6在内；所以是不使用‘box-sizing’属性的。第一个先看看双飞翼布局。 双飞翼布局首先，先给出页面结构，在三栏外面套一个容器，如下代码：1234567&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;center col&quot;&gt;&lt;/div&gt; &lt;div class=&quot;left col&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right col&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 上面就是我们第一步的页面结构，把center写在第一个是为了实现在浏览器优先渲染。 接下来我们先给三栏各自设置宽高，这里我们高度都用400px。因为中间栏宽度要自适应，所以我们设置为100%。123456789101112131415.col&#123; height:400px;&#125;.center&#123; width:100%; background:red;&#125;.left&#123; width:200px; background:green;&#125;.right&#123; width:200px; background:blue;&#125; 到这里，我们三栏的基本样式就出来了。此时，三栏并不在一行，那块级元素怎么才能一行显示呢？那就是通过浮动。所以，我们再加上12345678910111213141516.col&#123; height:400px; float:left;//新增&#125;.center&#123; width:100%; background:red;&#125;.left&#123; width:200px; background:green;&#125;.right&#123; width:200px; background:blue;&#125; 浮动的特点就是这一行占满了就会换行。因为中间栏已经占满了一行，所以此时两侧栏是在第二行的。那怎么才能让两个侧栏上来呢？这就是负外边距的作用。 1234567891011121314151617181920.col&#123; height:400px; float:left;&#125;.center&#123; width:100%; background:red;&#125;.left&#123; width:200px; background:green; //此处的100%是相对于父元素的，在此处也就是center的宽度 margin-left:-100%;//新增&#125;.right&#123; width:200px; background:blue; //此处的200px是自身的宽度 margin-left：-200px;//新增&#125; 到这里，三栏的基本布局就已经完成了。但是还有个问题，就是当我们在center中加入内容后，两边的内容会被两侧栏挡住，前面我们说了为了兼容性，我们是不使用box-sizing属性的，所以不能直接给center加padding属性。这里不理解的可以参考我另一篇文章：关于盒模型的理解 这时我们可以在center中新增一个子元素用来放置中间的内容，同时让它的左右外边距为左右两栏的宽度：123456789&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;center col&quot;&gt; &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;//新增 &lt;/div&gt; &lt;div class=&quot;left col&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right col&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 123456789101112131415161718192021.col &#123; height: 400px; float: left;&#125;.center &#123; width: 100%; background: red;&#125;.left &#123; width: 200px; background: green; margin-left: -100%; &#125;.right &#123; width: 200px; background: blue; margin-left:-200px;&#125;.main&#123; margin:0 200px;//新增&#125; 至此，我们就实现了双飞翼布局。须注意一点：因为两侧栏宽度是一定的，中间自适应，这样如果宽度缩小到一定程度中间的内容就会乱，所以一般我们都会给body加上min-width属性。 圣杯布局，下篇文章再见吧。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>双飞翼布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于函数重载和arguments]]></title>
    <url>%2F2017%2F03%2F24%2F%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E5%92%8Carguments%2F</url>
    <content type="text"><![CDATA[重载的概念重载，简单说，就是函数或者方法有相同的名称，但是参数列表(包括参数个数和参数类型)不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。 js中的函数重载js中没有重载。就是说，js不允许有名字相同的函数，如果你声明了两个名字相同的函数，后一个就会覆盖掉前一个。在js中，函数是作为一种特殊对象类型存在的，函数的名字只是一个普通的变量，本质与var a = 1中的变量a没什么区别。所以如果你先后定义了两个同名函数，实际上相当于先后将两个函数对象绑定到了同一个变量上，所以后者必然覆盖前者，不会共存，也自然不存在重载了。 js中的arguments总所周知，js是一门相当灵活的语言。当我们在js中在调用一个函数的时候，我们经常会给这个函数传递一些参数，js把传入到这个函数的全部参数存储在一个叫做arguments的东西里面，那么这到底是什么东西？在js中万物皆对象，甚至数组字符串函数都是对象。所以这个叫做arguments的东西也是个对象，而且是一个特殊的对象，它的属性名是按照传入参数的序列来的，第1个参数的属性名是’0’，第2个参数的属性名是’1’，以此类推，并且它还有length属性，存储的是当前传入函数参数的个数，很多时候我们把这种对象叫做类数组对象。关于类数组，此处不做详细讲解。接下来我们来看看arguments对象里面到底有些什么东西，是骡子是马拉出来溜溜。 12345function showargs() &#123; console.log( arguments );&#125;showargs(1,2,3,4,5); 打印结果： 这里我们可以看到arguments对象将我传入的五个参数以数组的形式保存在里面，还保存了我传入函数的实参的个数（length）。而且我们可以看到arguments对象的 _ proto _是指向object的，这也说明了他是个类数组对象，而不是一个数组。有了这个对象我们以后写函数的时候，就不用给所有的形参指定参数名，然后通过参数名的方式获取参数了，我们可以直接使用arguments对象来获取实参，这样是不是方便了很多呢。有些语言在我们给函数指定了参数名之后，当调用函数时，会判断当前传入的参数是否与函数定义的参数个数相等，不相等就会报错。但是灵活的js并不会验证传递给函数的参数个数是否等于函数定义的参数个数。所以代码的简洁度（为了装逼），我们使用arguments调用参数可以不混淆不同函数之间的参数名。另外代码的严整度（为了装逼），我们也能用arguments来判断当前传入参数的个数是否与我们需要的数量一致。下面举个栗子：12345678910function add() &#123; if( arguments.length == 2 )&#123; return arguments[0] + arguments[1]; &#125;else&#123; return &apos;传入参数不合法&apos;; &#125;&#125;console.log( add(2,3) );console.log( add(1,2,3) ); 看看结果：最后我们还可以看到arguments还有一个叫做callee的属性，这个属性是表示的是当前函数的一个引用。简单点说，这个属性里面存储的是我们调用的这个函数的代码，实在无法理解的时候，又到了console.log大显身手的时候了。12345678function showcallee() &#123; var a = &apos;这里是代码&apos;; var b = &apos;这是另一段代码&apos;; var c = a + b; console.log(arguments.callee); return c;&#125;showcallee(); 看看结果：看到结果的你是不是和我一样惊呆了呢，这不就是我写的代码吗？arguments.callee完完整整的把这个函数的这段代码返回了。 arguments和函数重载的关系上面说过了，由于js是一种弱类型的语言，没有重载机制，当我们重写函数时，会将原来的函数直接覆盖，这里我们能利用arguments，来判断传入的实参类型与数量进行不同的操作，然后返回不同的结果，来实现js中的函数重载。举个栗子：下面我们利用arguments对象来实现一个参数相加的函数，不论传入多少参数都行，将传入的参数相加后返回。 function add() { var len = arguments.length, sum = 0; for(;len--;){ sum += arguments[len]; } return sum; } console.log( add(1,2,3) ); //6 console.log( add(1,3) ); //4 console.log( add(1,2,3,5,6,2,7) ); //26 参考资料js的arguments到底是什么？]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>arguments</tag>
        <tag>函数重载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaScript中this的用法]]></title>
    <url>%2F2017%2F03%2F11%2Fthis%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言 this是JavaScript中一个比较难理解的点，很多新人会很迷惑。本文非原创，是阮一峰老师个人博客里的，个人感觉理解起来会很容易。拿来与大家分享。原文链接 正文this是Javascript语言的一个关键字。 它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。比如， 12345 function test()&#123; this.x = 1; &#125; 随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，==调用函数的那个对象。== 下面分四种情况，详细讨论this的用法。 情况一：纯粹的函数调用这是函数的最通常用法，属于全局性调用，因此this就代表全局对象Global。 请看下面这段代码，它的运行结果是1。123456789 function test()&#123; this.x = 1; alert(this.x); &#125; test(); // 1 为了证明this就是全局对象，我对代码做一些改变：123456789 var x = 1; function test()&#123; alert(this.x); &#125; test(); // 1 运行结果还是1。再变一下： 1234567891011 var x = 1; function test()&#123; this.x = 0; &#125; test(); alert(x); //0 情况二：作为对象方法的调用函数还可以作为某个对象的方法调用，这时this就指这个上级对象。 12345678910111213 function test()&#123; alert(this.x); &#125; var o = &#123;&#125;; o.x = 1; o.m = test; o.m(); // 1 情况三 ：作为构造函数调用所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this就指这个新对象。123456789 function test()&#123; this.x = 1; &#125; var o = new test(); alert(o.x); // 1 运行结果为1。为了表明这时this不是全局对象，我对代码做一些改变：1234567891011 var x = 2; function test()&#123; this.x = 1; &#125; var o = new test(); alert(x); //2 运行结果为2，表明全局变量x的值根本没变。 情况四： apply调用apply()是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。因此，this指的就是这第一个参数。 123456789101112131415 var x = 0; function test()&#123; alert(this.x); &#125; var o=&#123;&#125;; o.x = 1; o.m = test; o.m.apply(); //0 apply()的参数为空时，默认调用全局对象。因此，这时的运行结果为0，证明this指的是全局对象。 如果把最后一行代码修改为 : 1 o.m.apply(o); //1 运行结果就变成了1，证明了这时this代表的是对象o。]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>this</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中的深拷贝和浅拷贝]]></title>
    <url>%2F2017%2F03%2F01%2Fjs%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[两者的概念和区别对于基本数据类型(Undefined、Null、String、Number、Boolean)，浅拷贝是对值的复制，改变其中一个的值另一个不会跟着改变。对于对象来说，浅拷贝是对地址的复制，并没有开辟新的栈，也就是复制的结果是两个对象指向同一个地址，修改其中一个对象的属性，则另一个对象的属性也会改变；而深拷贝则是开辟新的栈，两个对象对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性。 深拷贝的实现方式关于深拷贝的实现，网上也有很多方式了。在此我总结了几种我用的比较多的。 方式一：递归拷贝1234567891011121314151617181920function deepClone(obj,newObj) &#123; if(typeof obj !== &apos;object&apos;)&#123; return obj; &#125; var newObj = newObj || &#123;&#125;; for(var key in obj)&#123; //首先判断是不是自身属性，如果不是，则跳过本次循环 if(!obj.hasOwnProperty(key))&#123; continue; &#125; if(typeof obj[key] === &apos;object&apos;)&#123; //判断是数组还是对象 newObj[key] = Object.prototype.toString.call(obj[key]) === &apos;[object Array]&apos;?[]:&#123;&#125;; deepClone(obj[key],newObj[key]); &#125;else&#123; newObj[key] = obj[key]; &#125; &#125; return newObj;&#125; 方式二：jquery中$.extent方法1234567891011121314var obj03 = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [1, 2, 3]&#125;;var obj04 = $.extend(true, &#123;&#125;, obj03);obj04.b.f = &#123; k : 2&#125;console.log(obj03.b.f === obj04.b.f); // false 方式三：JSON.parse方法123456789var obj = &#123; body: &#123; a: 10 &#125;&#125;;var shallowClone = obj;var deepClone = JSON.parse(JSON.stringify(obj));console.log(shallowClone.body === obj.body);//trueconsole.log(deepClone.body === obj.body);//false 以上三种方式都可以实现对对象的深拷贝。 对数组的深拷贝对数组的深拷贝可以使用下面这种方式：12345var ary = [&apos;one&apos;,&apos;two&apos;,&apos;three&apos;];var ary02 = ary.slice(0);ary02.push(&apos;four&apos;);console.log(ary);//[&apos;one&apos;,&apos;two&apos;,&apos;three&apos;]console.log(ary02);//[&apos;one&apos;,&apos;two&apos;,&apos;three&apos;,&apos;four&apos;] 上面是个人的总结，如果错误，欢迎留言交流！]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>深拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[not defined、undefined和null的区别]]></title>
    <url>%2F2017%2F02%2F24%2Fnot-defined%E3%80%81undefined%E5%92%8Cnull%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[not defined意为没有定义的变量。例：123&lt;script type=&quot;text/javascript&quot;&gt; console.log(m);&lt;/script&gt; 上述代码中m没有被定义，此时浏览器会报错 Uncaught ReferenceError: m is not defined undefinedundefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是： 变量被声明了，但没有赋值时，就等于undefined。 调用函数时，应该提供的参数没有提供，该参数等于undefined。 对象没有赋值的属性，该属性的值为undefined。 函数没有返回值时，默认返回undefined。 1234567891011var i;i // undefinedfunction f(x)&#123;console.log(x)&#125;f() // undefinedvar o = new Object();o.p // undefinedvar x = f();x // undefined 上面四种情况执行结果一样：不会报错，会打印出undefined。 nullnull表示 “没有对象”，即该处不应该有值。典型用法是： 作为函数的参数，表示该函数的参数不是对象。 作为对象原型链的终点。 12Object.getPrototypeOf(Object.prototype)// null 需要注意这里需要注意的是：null == undefined结果是true的，null === undefined结果是false的。 参考资料阮一峰：undefined与null的区别]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>undefined</tag>
        <tag>not defined</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查找某个元素在数组中的下标]]></title>
    <url>%2F2017%2F02%2F14%2F%E6%9F%A5%E6%89%BE%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E4%B8%8B%E6%A0%87%2F</url>
    <content type="text"><![CDATA[第一种：利用数组的findIndex方法,适用于元素是数字或者字符串 123456// 查找元素b的下标const arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]const index = arr.findIndex(item =&gt; &#123; return item === &apos;b&apos; &#125;)console.log(index) // 1 第二种：利用lodash插件中的findIndex方法，适用于元素是对象首先，通过npm安装 1$ npm i --save lodash 然后在项目中引入 1import _ from &apos;lodash&apos; 用法 12345678910111213141516const arr = [ &#123; name: &apos;xiaoming&apos;, age: 16 &#125;, &#123; name: &apos;lili&apos;, age: 18 &#125;, &#123; name: &apos;andy&apos;, age: 3 &#125;]const index = _.findIndex(arr, &#123; name: &apos;andy&apos; &#125;)console.log(index) // 2 扩展：lodash的深拷贝 12345const obj = &#123; name: &apos;xiaoming&apos;, age: 16&#125;const clonedObj = _.cloneDeep(obj)]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>下标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git使用笔记（二）]]></title>
    <url>%2F2017%2F01%2F17%2Fgit%E7%AC%94%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[关联远程仓库本地仓库与github的远程仓库关联的方式有两种： 第一种情况第一种情况，我们已经在本地创建了一个git仓库后，又想在GitHub创建一个git仓库，并且让这两个仓库进行远程同步。关联方式如下： 在GitHub上新建一个仓库（Repository），假如仓库命名为learngit; 在本地的git仓库运行命令： 12$ git remote add origin git@github.com:userName/learngit.git//userName为你的GitHub账户名 把本地库的所有内容推送到远程库上，由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来： 1$ git push -u origin master 以后的推送或者拉取时就可以简化命令： 1$ git push origin master 第二种情况假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。 在GitHub上新建一个仓库（Repository），假如仓库命名为rep; 克隆到本地12$ git clone git@github.com:userName/rep.git//userName为你的GitHub账户名 分支管理创建与合并分支注：name为分支名称。 查看当前本地分支：git branch 查看远程分支: git branch -r 查看已有的本地及远程分支：git branch -a 创建分支：git branch name 切换分支：git checkout name 创建+切换分支：git checkout -b name 合并name分支到当前分支：git merge name 删除本地分支：git branch -d name 强行删除本地分支：git branch -D name 删除远程分支：git push origin –delete name]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于盒模型的理解]]></title>
    <url>%2F2017%2F01%2F16%2F%E5%85%B3%E4%BA%8E%E7%9B%92%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言 盒子是无处不在的。html任何一个元素都可以看作一个盒子，这个盒子不可见，但是它存在于页面的每个角落。 盒子模型简介一个盒子包括了content（实际内容）、border（边框）、padding（内边距）和margin（外边距）。下图为一个盒子模型图： content（内容）盒子的内容，显示文本和图像。我们给元素设置的width和height其实是content的宽高， 如果指定高度大于显示内容所需高度，多余的高度会产生类似内边距一样的效果；如果指定高度小于显示内容所需高度，会出现滚动条。如果元素内容的高度大于元素框的高度，浏览器的具体行为取决于overflow属性。 border（边框）元素的边框是围绕元素内容的内边距的一条或多条线。边框由粗细、样式和颜色三部分组成。 padding（内边距）清除内容周围的区域，内边距是透明的，取值不能为负，受盒子的Background属性影响，padding是有背景的。 margin（外边距）在元素外创建额外的空白，空白通常指不能放其他元素的区域，而且在这个区域中可以看到父元素的背景（padding所带的是本身的背景而非父元素）。margin经常取负值实现定位的作用。 外边距有一个合并问题，经常使人们混淆，简单来说，外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。 两种盒子模型其实盒模型有两种，分别是ie盒子模型（IE6以下版本浏览器)和标准w3c盒子模型，区别在于前者content的宽度和高度包括了border和padding。 margin（外边界）虽不可见，但是它确实在文档中占据了空间，我们要区分两个概念即：盒子所占空间（计入margin ）和盒子实际的大小（不计入margin） 。 实例区分两种盒模型举个例子来区分两种盒模型：一个盒子的 margin 为 20px，border 为 2px，padding 为 10px，content 的宽为 200px、高为 50px。 在ie盒子模型中： 盒子所占空间：width=20ｘ2+200=240；height=20ｘ2+50=90 盒子实际大小：width=200；height=50 在标准w3c盒子模型中： 盒子所占空间：width=20ｘ2+2ｘ2+10ｘ2+200=264；height=20ｘ2+２ｘ2+10ｘ2 +50=114 盒子实际大小：width=200 +2ｘ2+10ｘ2=224；height=50+2ｘ2+10ｘ2=74 解释到这里，有的人可能会想起CSS3里面有个叫做box-sizing的属性，咦？两个盒模型不就是它不同取值下的效果吗？ box-sizing和两种盒模型不得不说的事box-sizing有三个取值： content-box:使元素遵循标准 w3c 盒子模型（默认值）。 border-box:使元素遵循ie 盒子模型。 inherit： 规定应从父元素继承 box-sizing 属性的值。 当你遵循ie盒子模型(box-sizing取值为border-box)时，不管你如何设置padding和border（小于width/2），它只在盒子里面伸缩，不影响整体的宽高，这个border-box是不是在某些时候非常好用？但也不能盲目地用，因为它会影响content，如果padding和border太大，会把内容挤掉的。 现在还在用IE6以下的浏览器的用户已经很少了，所以目前浏览器大部分元素都是基于W3C标准盒子模型 上。所以我们平常说的盒子模型一般就是标准w3c盒子模型（但对于input、button元素默认border-box，还是基于传统的ie 盒子模型）。 参考资料谈谈我对盒模型的理解]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>盒模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git使用笔记（一）]]></title>
    <url>%2F2017%2F01%2F16%2Fgit%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[注文中提到的工作区指还没add到暂存区的 版本库指已经把暂存区的commit后的 初始化初始化一个Git仓库，在当前文件夹，使用git init命令。 添加文件到Git仓库添加文件到Git仓库，分两步： 使用命令git add filename，注意，可反复多次使用，添加多个文件； 123$ git add file1.txt$ git add file2.txt file3.txt$ git commit -m &quot;add 3 files.&quot; 使用命令git commit -m ‘’，引号内为本次提交的说明，完成。 查看当前状态 要随时掌握工作区的状态，使用git status命令。 如果git status告诉你有文件被修改过，用git diff可以查看修改内容。注意，使用git diff查看修改内容是在add之前查看。 版本回退 首先，可以用git log查看提交的历史记录。 上图可以看出，共提交过两次。在Git中，用HEAD表示当前版本，也就是最新的提交。上一个版本就是HEAD\^，上上一个版本就是HEAD\^\^，当然往上100个版本写100个\^比较容易数不过来，所以写成HEAD~100。 使用git reset –hard HEAD\^命令，回退到上个版本。 回退到上个版本后，又后悔了怎么办？这时我们可以通过commit id来回到你想回到的任何版本。版本号写前面六七位就可以了。如：git reset –hard e8008 找不到commit id怎么办？可以使用git reflog查看你的每一次命令。 暂存区当我们修改或者新增文件，在git add fileName之前，通过git status查看当前的状态 然后通过git add fileName，就可以把修改的文件或者新增的文件放到暂存区。 此时，暂存区有一个修改过的文件和两个新增的文件。 由图中的提示可以看出，我们可以通过git reset HEAD fileName 来使指定文件退出暂存区。 git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit -m’’就可以一次性把暂存区的所有修改提交到分支。 撤销修改 当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – fileName。 当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD fileName，这个文件就回到了工作区，第二步按1操作。 已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退，不过前提是没有推送到远程库。 删除文件第一种情况当你在本地把文件删除后，这时版本库并没有删除，此时分两种情况： 删除版本库中的，git rm fileName 恢复本地的，git checkout – fileName。git checkout – fileName其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 注：版本库是已经提交（commit）的！ 第二种情况当你直接使用git rm fileName命令删除版本库中的文件后，在提交之前，可以参考撤销修改部分 参考资料廖雪峰的官方网站]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery中的事件委托]]></title>
    <url>%2F2016%2F12%2F23%2FjQuery%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%2F</url>
    <content type="text"><![CDATA[事件绑定的两种方式以click事件为例： 普通绑定事件： 123$(&apos;.btn1&apos;).click(function()&#123; &#125;) on绑定事件： 123$(document).on(&apos;click&apos;,&apos;.btn2&apos;,function()&#123; &#125;) 两种绑定方式的区别 click事件是在页面加载后，获取的所有类名为btn1的元素，然后绑定了这个click事件，要是通过其他操作再生成一个btn1元素，它就没有click这个事件； 而on()事件起到了监听的效果,可以实现动态html元素绑定，比如一开始只有一个btn2元素，通过某种方法又加了一个btn2元素，这个元素也可以点击，可以无限添加btn2。 举个栗子：12345&lt;ul&gt; &lt;li&gt;我是第一个&lt;/li&gt; &lt;li&gt;我是第二个&lt;/li&gt;&lt;/ul&gt;&lt;button&gt;添加&lt;/button&gt; 123$(&apos;button&apos;).click(function()&#123; $(&apos;ul&apos;).append($(&apos;&lt;li&gt;我是被添加的&lt;/li&gt;&apos;));&#125;) 通过点击’添加’按钮，我们在ul里动态添加了一个li，此时，通过click方式，新增加的li是没有点击事件的：123$(&apos;li&apos;).click(function()&#123; console.log($(this).text());&#125;) 而通过on方式给ul添加，我们后来添加的li也是有点击事件的：123$(&apos;ul&apos;).on(&apos;click&apos;,&apos;li&apos;,function()&#123; console.log($(this).text());&#125;) 事件委托原理那么怎么实现这个动态监听的过程呢？on()事件相当于是:12345$(&apos;ul&apos;).click(function()&#123; if(点击的是li)&#123; &#125;&#125;); 给ul添加了一个click事件，当点击的是li，事件冒泡原理，从里到外，就相当于点击了ul，那么就会执行后面的操作，本质上只给ul添加了一个事件。 事件委托的好处 原来的事件绑定，相当于给所有的li都要绑定事件，现在只需要给ul一个元素绑定事件，大大提高了效率和页面性能 解决了动态添加的元素不能触发事件的问题。 注意：jQuery1.7+开始支持 参考资料jQuery里面的普通绑定事件和on委托事件]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>事件委托</tag>
      </tags>
  </entry>
</search>
