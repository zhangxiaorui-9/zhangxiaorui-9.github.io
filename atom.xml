<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>不万能的杂货铺</title>
  
  <subtitle>Record my life</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kursaal.vip/"/>
  <updated>2019-04-17T08:45:44.308Z</updated>
  <id>http://kursaal.vip/</id>
  
  <author>
    <name>About Mr</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>flatten（扁平化）数组</title>
    <link href="http://kursaal.vip/2018/11/15/flatten%EF%BC%88%E6%89%81%E5%B9%B3%E5%8C%96%EF%BC%89%E6%95%B0%E6%95%B0%E7%BB%84/"/>
    <id>http://kursaal.vip/2018/11/15/flatten（扁平化）数数组/</id>
    <published>2018-11-15T01:32:15.000Z</published>
    <updated>2019-04-17T08:45:44.308Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.runoob.com/images/mix/65F53C2E-D255-4EE9-A675-F0C0F3F69D2B.png" alt="image"><br><a id="more"></a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>顾名思义，扁平化就是将嵌套的多维数组变成一维数组的过程。今天将通过几种方式来实现数组的扁平化。</p><p>先定义这几种方法公用的一个数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1, 2, [3, 4, [5, 6]]]</span><br></pre></td></tr></table></figure><h3 id="初级版"><a href="#初级版" class="headerlink" title="初级版"></a>初级版</h3><p>初级版也通过两种方式来实现</p><h4 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h4><p>利用数组的concat方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function flatten(arr) &#123;</span><br><span class="line">  let res = []  </span><br><span class="line">  arr.map(element =&gt; &#123;</span><br><span class="line">    if(Array.isArray(element)) &#123;</span><br><span class="line">      res = res.concat(flatten(element))</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">      res.push(element)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h4><p>使用参数默认值的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function flatten(arr, res = []) &#123;</span><br><span class="line">  for (let item of arr) &#123;</span><br><span class="line">    if (Array.isArray(item)) &#123;</span><br><span class="line">      res = flatten03(item, res)      </span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">      res.push(item)        </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进阶版"><a href="#进阶版" class="headerlink" title="进阶版"></a>进阶版</h3><p>使用…三点运算符结合concat方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function flatten(arr) &#123;</span><br><span class="line">  while(arr.some(item =&gt; Array.isArray(item))) &#123;</span><br><span class="line">    arr = [].concat(...arr)</span><br><span class="line">  &#125;</span><br><span class="line">  return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="终极版"><a href="#终极版" class="headerlink" title="终极版"></a>终极版</h3><p>Array.flat(n)是ES10扁平数组的api， n表示维度， n值为 Infinity时维度为无限大。<br>我们的例子中是个三维数组，所以，写法为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.flat(3)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://static.runoob.com/images/mix/65F53C2E-D255-4EE9-A675-F0C0F3F69D2B.png&quot; alt=&quot;image&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="javaScript" scheme="http://kursaal.vip/categories/javaScript/"/>
    
    
      <category term="flatten" scheme="http://kursaal.vip/tags/flatten/"/>
    
      <category term="扁平化" scheme="http://kursaal.vip/tags/%E6%89%81%E5%B9%B3%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>vue中的修饰符sync</title>
    <link href="http://kursaal.vip/2018/04/10/vue%E4%B8%AD%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6sync/"/>
    <id>http://kursaal.vip/2018/04/10/vue中的修饰符sync/</id>
    <published>2018-04-10T06:58:33.000Z</published>
    <updated>2019-03-05T07:30:06.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要使用sync"><a href="#为什么要使用sync" class="headerlink" title="为什么要使用sync"></a>为什么要使用sync</h2><p>在有些情况下，我们可能需要对一个 prop 进行“双向绑定”。不幸的是，真正的双向绑定会带来维护上的问题，因为子组件可以修改父组件，且在父组件和子组件都没有明显的改动来源。<br><a id="more"></a><br>.sync 修饰符所提供的功能。当一个子组件改变了一个 prop 的值时，这个变化也会同步到父组件中所绑定。就是说我们可以直接在我们需要传的prop后面加上 .sync</p><h2 id="使用方法和demo"><a href="#使用方法和demo" class="headerlink" title="使用方法和demo"></a>使用方法和demo</h2><p>比如我需要绑定 mes,然后我在他后面加上.sync。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;son :mes.sync="message"&gt;&lt;/son&gt;</span><br></pre></td></tr></table></figure><br>他会扩展成：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;son :mes="message" @update:mes="val =&gt; message= val"&gt;&lt;/son&gt;</span><br></pre></td></tr></table></figure><br>举个栗子：</p><p>父组件代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">   &lt;son :mes.sync='message'&gt;</span><br><span class="line">   &lt;/son&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Son from './Son.vue'</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: 'fathor',</span><br><span class="line">    components: &#123;</span><br><span class="line">        Son</span><br><span class="line">    &#125;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">            message: '我是父组件的数据'</span><br><span class="line">    &#125;     </span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>子组件代码：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input type=<span class="string">"text"</span> v-model=<span class="string">"mes"</span>/&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">        name:'son',</span><br><span class="line">        props:&#123;</span><br><span class="line">            mes: String</span><br><span class="line">        &#125;,</span><br><span class="line">        watch:&#123;</span><br><span class="line">            mes(newValue)&#123;</span><br><span class="line">                this.$emit('update:mes',newValue)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="与自定义事件的区别"><a href="#与自定义事件的区别" class="headerlink" title="与自定义事件的区别"></a>与自定义事件的区别</h2><p>看完上面的代码，你可能觉得这好像和“通过自定义事件（emit）从子组件向父组件中传递数据”是一样的。</p><p>其实并不一样， 两者有着父子组件关系上的不同， 下面我通过一行关键的代码证明它们的区别所在：</p><p>在我们使用.sync修饰符中， 自定义事件发生时候运行的响应表达式是：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;son :mes="message" @update:mes="val =&gt; message= val"&gt;&lt;/son&gt;</span><br></pre></td></tr></table></figure><p>在“通过自定义事件从子组件向父组件中传递数据” 里，自定义事件发生时候运行的响应表达式是:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;son @eventYouDefined = "arg =&gt; functionYours(arg)"&gt;&lt;/son&gt;</span><br></pre></td></tr></table></figure><p>对前者， 表达式 val =&gt; message = val意味着强制让父组件的数据等于子组件传递过来的数据， 这个时候，我们发现父子组件的地位是平等的。 父可以改变子（数据）， 子也可以改变父（数据）。</p><p>对后者， 你的functionYours是在父组件中定义的， 在这个函数里， 你可以对从子组件接受来的arg数据做任意的操作或处理， 决定权完全落在父组件中， 也就是：  父可以改变子（数据）， 但子不能直接改变父（数据）。 父中数据的变动只能由它自己决定。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/bf3bc4a9cd0d" target="_blank" rel="noopener">Vue使用.sync 实现父子组件的双向绑定数据</a><br><a href="https://www.cnblogs.com/penghuwan/p/7473375.html#_label0_2" target="_blank" rel="noopener">Vue中的父子组件通讯以及使用sync同步父子组件数据</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么要使用sync&quot;&gt;&lt;a href=&quot;#为什么要使用sync&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用sync&quot;&gt;&lt;/a&gt;为什么要使用sync&lt;/h2&gt;&lt;p&gt;在有些情况下，我们可能需要对一个 prop 进行“双向绑定”。不幸的是，真正的双向绑定会带来维护上的问题，因为子组件可以修改父组件，且在父组件和子组件都没有明显的改动来源。&lt;br&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://kursaal.vip/categories/Vue/"/>
    
    
      <category term="sync修饰符" scheme="http://kursaal.vip/tags/sync%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>多台电脑操作hexo个人网站</title>
    <link href="http://kursaal.vip/2018/03/28/%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E6%93%8D%E4%BD%9Chexo%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/"/>
    <id>http://kursaal.vip/2018/03/28/多台电脑操作hexo个人网站/</id>
    <published>2018-03-27T17:12:54.000Z</published>
    <updated>2019-03-05T07:30:06.047Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>最近换了个电脑，于是出现在新电脑上如何更新hexo个人网站的问题，网上各种方法，个人觉得还是有些不明白的地方，踩坑无数。最后终于成功，所以特此记下，也希望给其他人能有一些帮助。文章中用‘旧电脑’指代原来已经搭建好hexo的电脑，‘新电脑’指代即将要搭建hexo环境的电脑。</p></blockquote><a id="more"></a><h2 id="旧电脑上的操作"><a href="#旧电脑上的操作" class="headerlink" title="旧电脑上的操作"></a>旧电脑上的操作</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>首先确保自己已经使用hexo在github搭建好了自己的个人博客，github仓库中如下图显示：<img src="https://upload-images.jianshu.io/upload_images/2859254-e60e6b7e367b36fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="image"></p><h3 id="对username-github-io仓库新建hexo分支，并克隆"><a href="#对username-github-io仓库新建hexo分支，并克隆" class="headerlink" title="对username.github.io仓库新建hexo分支，并克隆"></a>对username.github.io仓库新建hexo分支，并克隆</h3><p>在Github的username.github.io（就是hexo网站的仓库）仓库上新建一个xxx（自己取名，我取名为hexo）分支，并切换到该分支，并在该仓库-&gt;Settings-&gt;Branches-&gt;Default   branch中将默认分支设为xxx，save保存。  </p><p>新建分支，并选中新建的分支，如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/2859254-01cb597e80e5005b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="image"></p><p>设置新建的xxx分支为默认分支，如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/2859254-67ed8c22531dd66d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="image"></p><p>然后将该仓库克隆到本地，进入到本地的username.github.io文件目录。<br>进入本地的username.github.io后，在当前目录使用git bash执行git branch命令查看当前所在分支，应为新建的分支xxx。  </p><h3 id="将本地博客的部署文件拷贝进username-github-io文件目录"><a href="#将本地博客的部署文件拷贝进username-github-io文件目录" class="headerlink" title="将本地博客的部署文件拷贝进username.github.io文件目录"></a>将本地博客的部署文件拷贝进username.github.io文件目录</h3><p>先将本地博客的部署文件（就是之前存放hexo项目的目录下的全部文件）全部拷贝进username.github.io文件目录中去。</p><p>接下来，进入username.github.io文件目录下，依次执行：</p><ol><li><strong>git add .</strong></li><li><strong>git commit -m ‘新电脑部署’</strong>（引号内容可改）</li><li><strong>git push</strong></li></ol><p>即可将博客的hexo部署环境提交到GitHub个人仓库的xxx分支。  </p><p>此时部署到github的步骤就已经完成了。master分支和xxx分支各自保存着一个版本，master分支用于保存博客静态资源，提供博客页面供人访问；xxx分支用于备份博客部署文件，供自己修改和更新，两者在一个GitHub仓库内互不冲突，完美！</p><h2 id="新电脑上的操作"><a href="#新电脑上的操作" class="headerlink" title="新电脑上的操作"></a>新电脑上的操作</h2><p>到这一步，你的博客已经可以在其他电脑上进行同步的维护和更新了，方法很简单：</p><ol><li>将新电脑生成的ssh key添加到GitHub账户上（生成并添加ssh key的方法自行百度，本文不做详细说明）。</li><li>在新电脑上克隆username.github.io仓库的xxx分支到本地，此时本地git仓库处于xxx分支.可以使用git branch查看当前分支。</li><li>切换到username.github.io目录，执行npm install(由于仓库有一个.gitignore文件，里面默认是忽略掉node_modules文件夹的，也就是说仓库的hexo分支并没有存储该目录，所以需要install下)</li><li>在新电脑上安装hexo命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure></li></ol><h2 id="新旧电脑更新网站的方法"><a href="#新旧电脑更新网站的方法" class="headerlink" title="新旧电脑更新网站的方法"></a>新旧电脑更新网站的方法</h2><p>首先注意一点：每次换电脑进行博客更新时，不管上次在其他电脑有没有更新，最好先git pull，防止冲突，这是一个好习惯。<br>然后，依次执行以下步骤：</p><ol><li>编辑、撰写文章或其他博客更新改动，就是你要对博客进行的修改，或新增文章。</li><li>依次执行git add .、git commit -m ‘在新电脑上提交新文章’（引号内容可改）、git push指令，保证xxx分支版本为最新版本。</li><li>依次执行hexo g,hexo d指令（执行之后，过几分钟如果网站上的内容没有更新，在hexo g之前，可能需要执行hexo clean），完成后就会发现，最新改动已经更新到master分支了，两个分支互不干扰！</li></ol><p>到此，就可以在多台电脑上更新个人网站啦！如有疑问，欢迎留言！</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/0b1fccce74e0" target="_blank" rel="noopener">利用Hexo在多台电脑上提交和更新博客</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;最近换了个电脑，于是出现在新电脑上如何更新hexo个人网站的问题，网上各种方法，个人觉得还是有些不明白的地方，踩坑无数。最后终于成功，所以特此记下，也希望给其他人能有一些帮助。文章中用‘旧电脑’指代原来已经搭建好hexo的电脑，‘新电脑’指代即将要搭建hexo环境的电脑。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="hexo" scheme="http://kursaal.vip/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://kursaal.vip/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>关于Vue中的计算属性computed</title>
    <link href="http://kursaal.vip/2018/03/12/%E5%85%B3%E4%BA%8EVue%E4%B8%AD%E7%9A%84%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7computed/"/>
    <id>http://kursaal.vip/2018/03/12/关于Vue中的计算属性computed/</id>
    <published>2018-03-12T08:30:09.000Z</published>
    <updated>2019-03-05T07:30:06.043Z</updated>
    
    <content type="html"><![CDATA[<h4 id="为什么要使用计算属性（computed）"><a href="#为什么要使用计算属性（computed）" class="headerlink" title="为什么要使用计算属性（computed）"></a>为什么要使用计算属性（computed）</h4><p>我们都知道，在Vue中，对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。<br>看看代码:<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; number + 1 &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; ok ? &apos;YES&apos; : &apos;NO&apos; &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;div v-bind:id=&quot;&apos;list-&apos; + id&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含单个表达式，所以下面的例子都不会生效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 这是语句，不是表达式 --&gt;</span><br><span class="line"></span><br><span class="line">&#123;&#123; var a = 1 &#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;</span><br><span class="line"></span><br><span class="line">&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125;</span><br></pre></td></tr></table></figure><p>模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example&quot;&gt;</span><br><span class="line">  &#123;&#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>在这个地方，模板不再是简单的声明式逻辑。你必须看一段时间才能意识到，这里是想要显示变量 message 的翻转字符串。当你想要在模板中多次引用此处的翻转字符串时，就会更加难以处理。<br>所以，对于任何复杂逻辑，你都应当使用计算属性。一个简单的例子：<br>html：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example&quot;&gt;</span><br><span class="line">  &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>js：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#example&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &apos;Hello&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    // 计算属性的 getter</span><br><span class="line">    reversedMessage: function () &#123;</span><br><span class="line">      // `this` 指向 vm 实例</span><br><span class="line">      return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>结果：</p><blockquote><p>Original message: “Hello”<br>Computed reversed message: “olleH”</p></blockquote><p>这里我们声明了一个计算属性 <em>reversedMessage</em>。我们提供的函数将用作属性 vm.reversedMessage的 <em>getter</em> 函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(vm.reversedMessage) // =&gt; &apos;olleH&apos;</span><br><span class="line">vm.message = &apos;Goodbye&apos;</span><br><span class="line">console.log(vm.reversedMessage) // =&gt; &apos;eybdooG&apos;</span><br></pre></td></tr></table></figure><p>你可以打开浏览器的控制台，自行修改例子中的 vm。vm.reversedMessage 的值始终取决于 vm.message 的值。 </p><p>你可以像绑定普通属性一样在模板中绑定计算属性。Vue 知道 vm.reversedMessage 依赖于 vm.message，因此当 vm.message 发生改变时，所有依赖 vm.reversedMessage 的绑定也会更新。而且最妙的是我们已经以声明的方式创建了这种依赖关系：计算属性的 <em>getter</em> 函数是没有副作用 (side effect)的，这使它更易于测试和理解。</p><h4 id="计算属性-computed-与方法（methods）的区别"><a href="#计算属性-computed-与方法（methods）的区别" class="headerlink" title="计算属性(computed) 与方法（methods）的区别"></a>计算属性(computed) 与方法（methods）的区别</h4><p>你可能已经注意到我们可以通过在表达式中调用方法来达到同样的效果：</p><p>html：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Reversed message: &quot;&#123;&#123; reversedMessage() &#125;&#125;&quot;&lt;/p&gt;</span><br></pre></td></tr></table></figure></p><p>js：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 在组件中</span><br><span class="line">methods: &#123;</span><br><span class="line">  reversedMessage: function () &#123;</span><br><span class="line">    return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以将同一函数定义为一个方法（methods）而不是一个计算属性（computed）。两种方式的最终结果确实是完全相同的。然而， <strong>不同的是计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。</strong> 这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而<strong>不必再次</strong>执行函数。</p><p>这也同样意味着下面的计算属性将不再更新，因为 Date.now() 不是响应式依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  now: function () &#123;</span><br><span class="line">    return Date.now()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>相比之下，每当触发重新渲染时，调用方法（methods）将<strong>总会</strong>再次执行函数。</p><p>我们为什么需要缓存？假设我们有一个性能开销比较大的的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 <em>getter</em>！如果你不希望有缓存，请用方法（methods）来替代。  </p><h4 id="计算属性-computed-与侦听属性（watch）"><a href="#计算属性-computed-与侦听属性（watch）" class="headerlink" title="计算属性(computed)与侦听属性（watch）"></a>计算属性(computed)与侦听属性（watch）</h4><p>Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性（watch）。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch——特别是如果你之前使用过 AngularJS。然而，通常更好的做法是使用计算属性（computed）而不是命令式的 watch 回调。细想一下这个例子：</p><p>html：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;demo&quot;&gt;&#123;&#123; fullName &#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>js：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#demo&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: &apos;Foo&apos;,</span><br><span class="line">    lastName: &apos;Bar&apos;,</span><br><span class="line">    fullName: &apos;Foo Bar&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    firstName: function (val) &#123;</span><br><span class="line">      this.fullName = val + &apos; &apos; + this.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    lastName: function (val) &#123;</span><br><span class="line">      this.fullName = this.firstName + &apos; &apos; + val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>上面代码是命令式且重复的。将它与计算属性（computed）的版本进行比较：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#demo&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: &apos;Foo&apos;,</span><br><span class="line">    lastName: &apos;Bar&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    fullName: function () &#123;</span><br><span class="line">      return this.firstName + &apos; &apos; + this.lastName</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>是不是好了很多呢？</p><h4 id="计算属性的setter"><a href="#计算属性的setter" class="headerlink" title="计算属性的setter"></a>计算属性的setter</h4><p>计算属性默认只有 <em>getter</em> ，不过在需要时你也可以提供一个 <em>setter</em> ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    // getter</span><br><span class="line">    get: function () &#123;</span><br><span class="line">      return this.firstName + &apos; &apos; + this.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    // setter</span><br><span class="line">    set: function (newValue) &#123;</span><br><span class="line">      var names = newValue.split(&apos; &apos;)</span><br><span class="line">      this.firstName = names[0]</span><br><span class="line">      this.lastName = names[names.length - 1]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure></p><p>现在再运行 vm.fullName = ‘John Doe’ 时，<em>setter</em> 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">vue官网</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;为什么要使用计算属性（computed）&quot;&gt;&lt;a href=&quot;#为什么要使用计算属性（computed）&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用计算属性（computed）&quot;&gt;&lt;/a&gt;为什么要使用计算属性（computed）&lt;/h4&gt;&lt;p&gt;我们都知道，在Vue中，对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。&lt;br&gt;看看代码:&lt;br&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://kursaal.vip/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://kursaal.vip/tags/Vue/"/>
    
      <category term="computed" scheme="http://kursaal.vip/tags/computed/"/>
    
  </entry>
  
  <entry>
    <title>v-if和v-show的使用和区别</title>
    <link href="http://kursaal.vip/2018/02/23/v-if%E5%92%8Cv-show%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8C%BA%E5%88%AB/"/>
    <id>http://kursaal.vip/2018/02/23/v-if和v-show的使用和区别/</id>
    <published>2018-02-23T13:25:33.000Z</published>
    <updated>2019-03-05T07:30:06.041Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>专门记一篇关于vue条件渲染的文章似乎没有必要，刚开始也没打算记。但在应用过程中有时会有点迷惑，什么时候用v-if，什么时候用v-show，这两者有什么区别？所以，还是决定记一下，虽然大部分都是官网的介绍，但俗话说，眼过千变不如手过一遍。所以，记此篇。 </p></blockquote><a id="more"></a><h2 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h2><p>在字符串模板中，比如 Handlebars，我们得像这样写一个条件块：<br>html代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Handlebars 模板 --&gt;</span><br><span class="line">&#123;&#123;#if ok&#125;&#125;</span><br><span class="line">  &lt;h1&gt;Yes&lt;/h1&gt;</span><br><span class="line">&#123;&#123;/if&#125;&#125;</span><br></pre></td></tr></table></figure></p><p>在 Vue 中，我们使用 v-if 指令实现同样的功能：<br>html代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 v-if=&quot;ok&quot;&gt;Yes&lt;/h1&gt;</span><br></pre></td></tr></table></figure></p><p>也可以用 v-else 添加一个“else 块”：<br>html代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 v-if=&quot;ok&quot;&gt;Yes&lt;/h1&gt;</span><br><span class="line">&lt;h1 v-else&gt;No&lt;/h1&gt;</span><br></pre></td></tr></table></figure></p><h3 id="在-template-元素上使用-v-if-条件渲染分组"><a href="#在-template-元素上使用-v-if-条件渲染分组" class="headerlink" title="在 template 元素上使用 v-if 条件渲染分组"></a>在 template 元素上使用 v-if 条件渲染分组</h3><p>因为 v-if是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个 template 元素当做不可见的包裹元素，并在上面使用 v-if。最终的渲染结果将不包含 template 元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-if=&quot;ok&quot;&gt;</span><br><span class="line">  &lt;h1&gt;Title&lt;/h1&gt;</span><br><span class="line">  &lt;p&gt;Paragraph 1&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Paragraph 2&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h3 id="v-else"><a href="#v-else" class="headerlink" title="v-else"></a>v-else</h3><p>你可以使用 v-else 指令来表示 v-if 的“else 块”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-if=&quot;Math.random() &gt; 0.5&quot;&gt;</span><br><span class="line">  Now you see me</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div v-else&gt;</span><br><span class="line">  Now you don&apos;t</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>v-else 元素<strong>必须紧跟</strong>在带 v-if 或者 v-else-if 的元素的后面，否则它将不会被识别。</p><h3 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if"></a>v-else-if</h3><p>v-else-if，顾名思义，充当 v-if 的“else-if 块”，可以连续使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-if=&quot;type === &apos;A&apos;&quot;&gt;</span><br><span class="line">  A</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div v-else-if=&quot;type === &apos;B&apos;&quot;&gt;</span><br><span class="line">  B</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div v-else-if=&quot;type === &apos;C&apos;&quot;&gt;</span><br><span class="line">  C</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div v-else&gt;</span><br><span class="line">  Not A/B/C</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>类似于 v-else，v-else-if 也 <em>必须紧跟</em> 在带 v-if 或者 v-else-if 的元素之后!</p><h3 id="用-key-管理可复用的元素"><a href="#用-key-管理可复用的元素" class="headerlink" title="用 key 管理可复用的元素"></a>用 key 管理可复用的元素</h3><p>Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使Vue变得非常快之外，还有其它一些好处。例如，如果你允许用户在不同的登录方式之间切换：<br>html代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-if=&quot;loginType === &apos;username&apos;&quot;&gt;</span><br><span class="line">  &lt;label&gt;Username&lt;/label&gt;</span><br><span class="line">  &lt;input placeholder=&quot;Enter your username&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;template v-else&gt;</span><br><span class="line">  &lt;label&gt;Email&lt;/label&gt;</span><br><span class="line">  &lt;input placeholder=&quot;Enter your email address&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p><p>那么在上面的代码中切换 loginType <em>将不会清除</em>用户已经输入的内容。因为两个模板使用了相同的元素，input标签不会被替换掉——仅仅是替换了它的 placeholder。</p><p>这样也不总是符合实际需求，所以 Vue 为你提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 <em>key</em> 属性即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-if=&quot;loginType === &apos;username&apos;&quot;&gt;</span><br><span class="line">  &lt;label&gt;Username&lt;/label&gt;</span><br><span class="line">  &lt;input placeholder=&quot;Enter your username&quot; key=&quot;username-input&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;template v-else&gt;</span><br><span class="line">  &lt;label&gt;Email&lt;/label&gt;</span><br><span class="line">  &lt;input placeholder=&quot;Enter your email address&quot; key=&quot;email-input&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p><p>现在，每次切换时，输入框都将被重新渲染。  </p><p>注意，label元素仍然会被高效地复用，因为它们没有添加 key 属性。</p><h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h2><p>另一个用于根据条件展示元素的选项是 v-show 指令。用法大致一样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt;</span><br></pre></td></tr></table></figure></p><p>不同的是带有v-show的元素<strong>始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS 属性 display。</strong></p><p><strong>注意，v-show 不支持 template 元素，也不支持 v-else。</strong></p><h2 id="v-if-vs-v-show"><a href="#v-if-vs-v-show" class="headerlink" title="v-if vs v-show"></a>v-if vs v-show</h2><p>v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被<em>销毁和重建</em>。</p><p>v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p><p>相比之下，v-show 就简单得多——不管初始条件是什么，元素<em>总是会被渲染</em>，并且只是简单地基于 CSS 进行切换。</p><p>一般来说，<strong>v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销</strong>。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;专门记一篇关于vue条件渲染的文章似乎没有必要，刚开始也没打算记。但在应用过程中有时会有点迷惑，什么时候用v-if，什么时候用v-show，这两者有什么区别？所以，还是决定记一下，虽然大部分都是官网的介绍，但俗话说，眼过千变不如手过一遍。所以，记此篇。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://kursaal.vip/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://kursaal.vip/tags/Vue/"/>
    
      <category term="v-if" scheme="http://kursaal.vip/tags/v-if/"/>
    
      <category term="v-show" scheme="http://kursaal.vip/tags/v-show/"/>
    
  </entry>
  
  <entry>
    <title>for in和for of的区别</title>
    <link href="http://kursaal.vip/2017/08/29/for-in%E5%92%8Cfor-of%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://kursaal.vip/2017/08/29/for-in和for-of的区别/</id>
    <published>2017-08-29T08:17:15.000Z</published>
    <updated>2019-04-17T08:45:03.567Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1555500528968&amp;di=991e325c9d04c29d1d58a258272046f6&amp;imgtype=0&amp;src=http%3A%2F%2Fs3.lvjs.com.cn%2Fuploads%2Fpc%2Fplace2%2F2018-06-22%2F4a29a65b-245a-487d-b6c5-50ea8b82a725.jpg" alt="image"><br><a id="more"></a></p><h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><p>以前我们遍历数组通常使用for循环，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;apple&apos;, &apos;orange&apos;, &apos;banana&apos;]</span><br><span class="line">for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    console.log(arr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES5的话也可以使用forEach，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;apple&apos;, &apos;orange&apos;, &apos;banana&apos;]</span><br><span class="line">arr.forEach(function(val) &#123;</span><br><span class="line">    console.log(val)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>但是使用forEach遍历数组的话，使用break不能中断循环，使用return也不能返回到外层函数。</p><p>ES5具有遍历数组功能的还有<strong>map</strong>、<strong>filter</strong>、<strong>some</strong>、<strong>every</strong>等，只不过他们的返回结果不一样。</p><p>使用for in也可以遍历数组，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.method = function()&#123;</span><br><span class="line">　console.log(this.length)</span><br><span class="line">&#125;</span><br><span class="line">var arr = [&apos;apple&apos;, &apos;orange&apos;, &apos;banana&apos;]</span><br><span class="line">arr.name = &quot;数组&quot;</span><br><span class="line">for (var index in arr) &#123;</span><br><span class="line">  console.log(arr[index])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apple</span><br><span class="line">orange</span><br><span class="line">banana</span><br><span class="line">数组</span><br><span class="line">ƒ ()&#123;</span><br><span class="line">　console.log(this.length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由打印的结果可以看出，使用for in会遍历数组所有的可枚举属性，包括原型。例如上面栗子中的原型方法method和name属性。   </p><p>除此之外，使用for in遍历数组还会存在以下问题：</p><ol><li>index索引为字符串型数字，不能直接进行几何运算</li><li>遍历顺序有可能不是按照实际数组的内部顺序</li></ol><p>所以for in更适合遍历对象，不要使用for in遍历数组。</p><p>那么除了使用for循环，如何更简单的正确的遍历数组达到我们的期望呢（即不遍历method和name），ES6中的for of是个很好的选择。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.method = function()&#123;</span><br><span class="line">　console.log(this.length)</span><br><span class="line">&#125;</span><br><span class="line">const arr = [&apos;apple&apos;, &apos;orange&apos;, &apos;banana&apos;]</span><br><span class="line">arr.name=&quot;数组&quot;;</span><br><span class="line">for (var value of arr) &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;</span><br><span class="line">// &apos;apple&apos;, &apos;orange&apos;, &apos;banana&apos;</span><br></pre></td></tr></table></figure><p>打印结果可以看出，for of遍历的只是数组内的元素，而不包括数组的原型属性method和索引name。</p><h3 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h3><p>通常用for in来遍历对象的键名，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.method = function() &#123;</span><br><span class="line">　console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">var myObject=&#123;</span><br><span class="line">　a:1,</span><br><span class="line">　b:2,</span><br><span class="line">　c:3</span><br><span class="line">&#125;</span><br><span class="line">for (var key in myObject) &#123;</span><br><span class="line">  console.log(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>for in可以遍历到myObject的原型方法method。<br>如果不想遍历原型方法和属性的话，可以在循环内部判断下,hasOwnPropery方法可以判断某属性是否是该对象的实例属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (var key in myObject) &#123;</span><br><span class="line">　if（myObject.hasOwnProperty(key))&#123;</span><br><span class="line">　　console.log(key);</span><br><span class="line">　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者可以通过ES5的Object.keys(myObject)获取对象的实例属性组成的数组，不包括原型方法和属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object.keys(myObject).forEach(function(key) &#123;</span><br><span class="line"> console.log(myObject[key])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>for in遍历的是数组的索引（即键名），而for of遍历的是数组元素值。</li><li>for in更适合遍历对象，for of更适合遍历数组。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1555500528968&amp;amp;di=991e325c9d04c29d1d58a258272046f6&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Fs3.lvjs.com.cn%2Fuploads%2Fpc%2Fplace2%2F2018-06-22%2F4a29a65b-245a-487d-b6c5-50ea8b82a725.jpg&quot; alt=&quot;image&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="javaScript" scheme="http://kursaal.vip/categories/javaScript/"/>
    
    
      <category term="for of" scheme="http://kursaal.vip/tags/for-of/"/>
    
      <category term="for in" scheme="http://kursaal.vip/tags/for-in/"/>
    
  </entry>
  
  <entry>
    <title>js常见算法题</title>
    <link href="http://kursaal.vip/2017/08/16/js%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <id>http://kursaal.vip/2017/08/16/js常见算法题/</id>
    <published>2017-08-16T11:58:53.000Z</published>
    <updated>2019-03-05T07:30:06.039Z</updated>
    
    <content type="html"><![CDATA[<h4 id="判断一个单词是否是回文"><a href="#判断一个单词是否是回文" class="headerlink" title="判断一个单词是否是回文"></a>判断一个单词是否是回文</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str = 'helloolleh';</span><br><span class="line">function checkPalindrom(str) &#123;</span><br><span class="line">    return str == str.split('').reverse().join('');</span><br><span class="line">&#125;</span><br><span class="line">console.log(checkPalindrom(str));<span class="comment">//true</span></span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="去掉一组整型数组重复的值"><a href="#去掉一组整型数组重复的值" class="headerlink" title="去掉一组整型数组重复的值"></a>去掉一组整型数组重复的值</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let arr = [<span class="number">1</span>, <span class="number">13</span>, <span class="number">24</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">14</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br></pre></td></tr></table></figure><h5 id="第一种方法：Object方法。主要考察个人对Object的使用，利用key来进行筛选。"><a href="#第一种方法：Object方法。主要考察个人对Object的使用，利用key来进行筛选。" class="headerlink" title="第一种方法：Object方法。主要考察个人对Object的使用，利用key来进行筛选。"></a>第一种方法：Object方法。主要考察个人对Object的使用，利用key来进行筛选。</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let unique = function (arr) &#123;</span><br><span class="line">    let hashTable = &#123;&#125;;</span><br><span class="line">    let data = [];</span><br><span class="line">    <span class="keyword">for</span> (let i = <span class="number">0</span>, l = arr.length; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hashTable[arr[i]]) &#123;</span><br><span class="line">            hashTable[arr[i]] = <span class="literal">true</span>;</span><br><span class="line">            data.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;   </span><br><span class="line">console.log(unique(arr));<span class="comment">//[1,13,24,11,14,2]</span></span><br></pre></td></tr></table></figure><h5 id="第二种方法：Set方法"><a href="#第二种方法：Set方法" class="headerlink" title="第二种方法：Set方法"></a>第二种方法：Set方法</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let newArr = Array.from(new Set(arr));</span><br><span class="line">console.log(newArr);<span class="comment">//[1,13,24,11,14,2]</span></span><br></pre></td></tr></table></figure><h5 id="第三种方法：indexOf方法"><a href="#第三种方法：indexOf方法" class="headerlink" title="第三种方法：indexOf方法"></a>第三种方法：indexOf方法</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let unique02 = function(arr)&#123;</span><br><span class="line">    let newArr = [arr[<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">for</span>(let i = <span class="number">1</span>;i &lt; arr.length;i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(newArr.indexOf(arr[i]) == <span class="number">-1</span>)&#123;</span><br><span class="line">            newArr.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line">console.log(unique02(arr));<span class="comment">//[1,13,24,11,14,2]</span></span><br></pre></td></tr></table></figure><h4 id="统计一个字符串出现最多的字母"><a href="#统计一个字符串出现最多的字母" class="headerlink" title="统计一个字符串出现最多的字母"></a>统计一个字符串出现最多的字母</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">let str = 'afjghdfraaaasdenas';</span><br><span class="line">function findMaxDuplicateChar(str) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    let charObj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (let i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!charObj[str.charAt(i)]) &#123;</span><br><span class="line">            charObj[str.charAt(i)] = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            charObj[str.charAt(i)] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let maxChar = '',</span><br><span class="line">        maxValue = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (var k <span class="keyword">in</span> charObj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (charObj[k] &gt;= maxValue) &#123;</span><br><span class="line">            maxChar = k;</span><br><span class="line">            maxValue = charObj[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxChar;</span><br><span class="line">&#125;</span><br><span class="line">console.log(findMaxDuplicateChar(str));<span class="comment">//a</span></span><br></pre></td></tr></table></figure><h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let arr = [<span class="string">'a'</span>,<span class="string">'d'</span>,<span class="string">'c'</span>,<span class="string">'b'</span>];</span><br></pre></td></tr></table></figure><h5 id="第一种：冒泡排序"><a href="#第一种：冒泡排序" class="headerlink" title="第一种：冒泡排序"></a>第一种：冒泡排序</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function bubbleSort(arr)&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(let i = <span class="number">0</span>;i &lt; arr.length<span class="number">-1</span>;i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(let j = i+<span class="number">1</span>;j &lt; arr.length;j ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[j])&#123;</span><br><span class="line">                let temp = arr[i];</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line">console.log(bubbleSort(arr));<span class="comment">//['a','b','c','d']</span></span><br></pre></td></tr></table></figure><h5 id="第二种：快速排序"><a href="#第二种：快速排序" class="headerlink" title="第二种：快速排序"></a>第二种：快速排序</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function quickSort(arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    let leftArr = [];</span><br><span class="line">    let rightArr = [];</span><br><span class="line">    let q = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (let i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; q) &#123;</span><br><span class="line">            rightArr.push(arr[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            leftArr.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [].concat(quickSort(leftArr), [q], quickSort(rightArr));</span><br><span class="line">&#125;</span><br><span class="line">console.log(quickSort(arr));<span class="comment">//['a','b','c','d']</span></span><br></pre></td></tr></table></figure><h4 id="随机生成指定长度的字符串"><a href="#随机生成指定长度的字符串" class="headerlink" title="随机生成指定长度的字符串"></a>随机生成指定长度的字符串</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数n为要生成的字符串长度</span></span><br><span class="line">function randomString(n) &#123;</span><br><span class="line">    let str = 'abcdefghijklmnopqrstuvwxyz9876543210';</span><br><span class="line">    let tmp = '',</span><br><span class="line">        i = <span class="number">0</span>,</span><br><span class="line">        l = str.length;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        tmp += str.charAt(Math.floor(Math.random() * l));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="找出正数组的最大差值"><a href="#找出正数组的最大差值" class="headerlink" title="找出正数组的最大差值"></a>找出正数组的最大差值</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [<span class="number">10</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>很明显我们知道，最大差值肯定是一个数组中最大值与最小值的差。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function getMaxProfit(arr) &#123;</span><br><span class="line">    var minPrice = arr[<span class="number">0</span>];</span><br><span class="line">    var maxProfit = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (var i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        var currentPrice = arr[i];</span><br><span class="line">        minPrice = Math.min(minPrice, currentPrice);</span><br><span class="line">        var potentialProfit = currentPrice - minPrice;</span><br><span class="line">        maxProfit = Math.max(maxProfit, potentialProfit);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit;</span><br><span class="line">&#125;</span><br><span class="line">console.log(getMaxProfit(arr));<span class="comment">//6</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;判断一个单词是否是回文&quot;&gt;&lt;a href=&quot;#判断一个单词是否是回文&quot; class=&quot;headerlink&quot; title=&quot;判断一个单词是否是回文&quot;&gt;&lt;/a&gt;判断一个单词是否是回文&lt;/h4&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var str = &#39;helloolleh&#39;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function checkPalindrom(str) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return str == str.split(&#39;&#39;).reverse().join(&#39;&#39;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(checkPalindrom(str));&lt;span class=&quot;comment&quot;&gt;//true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="javaScript" scheme="http://kursaal.vip/categories/javaScript/"/>
    
    
      <category term="js算法" scheme="http://kursaal.vip/tags/js%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>jsonp解决跨域问题</title>
    <link href="http://kursaal.vip/2017/08/13/jsonp%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    <id>http://kursaal.vip/2017/08/13/jsonp解决跨域问题/</id>
    <published>2017-08-13T02:32:07.000Z</published>
    <updated>2019-04-17T08:44:27.151Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.runoob.com/images/mix/BFD206B6-07E8-41B5-AF88-924CECFCA256.png" alt="image"><br><a id="more"></a><br>jsonp名字听上去挺高大上，实际只要理解了就是个矮穷矬。</p><h4 id="jsonp原理"><a href="#jsonp原理" class="headerlink" title="jsonp原理"></a>jsonp原理</h4><p>利用script标签没有跨域限制的“漏洞”，来达到与第三方通讯的目的。 </p><p>第三方产生的响应为json数据的包装（故称之为jsonp，即json padding）。  </p><p>它的基本思想是，网页通过添加一个script元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。  </p><p>首先，网页动态插入script元素，由它向跨源网址发出请求。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function addScriptTag(src) &#123;</span><br><span class="line">  var script = document.createElement(&apos;script&apos;);</span><br><span class="line">  script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);</span><br><span class="line">  script.src = src;</span><br><span class="line">  document.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">window.onload = function () &#123;</span><br><span class="line">  addScriptTag(&apos;http://example.com/ip?callback=foo&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function foo(data) &#123;</span><br><span class="line">  console.log(&apos;Your public IP address is: &apos; + data.ip);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码通过动态添加script元素，向服务器example.com发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于JSONP是必需的。<br>服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo(&#123;</span><br><span class="line">  &quot;ip&quot;: &quot;8.8.8.8&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>由于script元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用JSON.parse的步骤。</p><h4 id="面试中的问题"><a href="#面试中的问题" class="headerlink" title="面试中的问题"></a>面试中的问题</h4><ol><li>知道 jsonp么？<br>答：知道，可以实现跨域请求；<br>答不知道：换别的话题。</li><li>为什么 ajax 不可以，但是 jsonp 可以实现跨域请求呢？<br>答：因为 jsonp 是通过插入一个 script 标签，利用 script 可以跨域请求来实现的。换问题3；<br>答：面试官傻逼，ajax 现在也可以使用 cors 来做跨域请求；换问题 2.5。<br>答不知道：换问题 2.5。<br>2.5  jsonp实现原理？<br>答：通过创建一个 script 标签，将 src 设置为目标请求，插入到 dom 中，服务器接受该请求并返回数据，数据通常被包裹在回调钩子中；<br>回答不知道：我自己解释 jsonp 的实现。  </li><li>可以用 jsonp 发送 post 请求么？<br>答：显然不行，看过支持 post 请求的 script 么？<br>答不知道：反问，看过支持 post 请求的 script 么？  </li><li>参考 jsonp，还有那些发送跨域请求的途径？<br>答：img link iframe 等元素都可以发送跨域请求呀！<br>答不知道：反问img link iframe 等元素是不是也可以？</li></ol><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">浏览器同源政策及其规避方法</a><br><a href="https://www.zhihu.com/question/28890257/answer/269738446" target="_blank" rel="noopener">jsonp为什么不支持post请求，寸志的回答</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://static.runoob.com/images/mix/BFD206B6-07E8-41B5-AF88-924CECFCA256.png&quot; alt=&quot;image&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="javaScript" scheme="http://kursaal.vip/categories/javaScript/"/>
    
    
      <category term="跨域" scheme="http://kursaal.vip/tags/%E8%B7%A8%E5%9F%9F/"/>
    
      <category term="jsonp" scheme="http://kursaal.vip/tags/jsonp/"/>
    
  </entry>
  
  <entry>
    <title>js中的函数节流（throttle）和函数去抖（debounce）</title>
    <link href="http://kursaal.vip/2017/07/22/js%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%EF%BC%88throttle%EF%BC%89%E5%92%8C%E5%87%BD%E6%95%B0%E5%8E%BB%E6%8A%96%EF%BC%88debounce%EF%BC%89/"/>
    <id>http://kursaal.vip/2017/07/22/js中的函数节流（throttle）和函数去抖（debounce）/</id>
    <published>2017-07-22T11:49:56.000Z</published>
    <updated>2019-03-05T07:30:06.037Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在js中，我们经常会遇到这种情况，需要监听页面的scroll事件或者鼠标的mousemove事件等。由于这些事件在鼠标移动的过程中会被浏览器频繁的触发，会导致对应的事件也会被频繁的触发，这样就会造成很大的浏览器资源开销，而且好多中间的处理是不必要的，这样就会造成浏览器卡顿的现象。我们无法做到让浏览器不去触发对应的事件，但是可以做到让处理事件的方法执行频率减少（throttle）或者在执行动作完成后执行一次（debounce），从而减少对应的处理开销。</p></blockquote><a id="more"></a><h2 id="throttle和debounce的区别"><a href="#throttle和debounce的区别" class="headerlink" title="throttle和debounce的区别"></a>throttle和debounce的区别</h2><p>throttle指，在动作执行过程中，隔断时间触发一次事件，这样可以减少事件的方法执行的频率。debounce指只在动作结束后触发一次，把中间的处理函数全部过滤掉了，只执行规判定时间内的最后一个事件。</p><p>一般window的resize，input的keyup事件使用debounce；scroll、mousemove等事件使用throttle。</p><h2 id="throttle的实现"><a href="#throttle的实现" class="headerlink" title="throttle的实现"></a>throttle的实现</h2><p>直接上代码  </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现思路</span></span><br><span class="line"><span class="comment">//两个参数：一个对应的处理函数,一个执行的频率</span></span><br><span class="line"><span class="comment">//内部需要一个lastTime变量记录上一次执行的时间</span></span><br><span class="line">function throttle (func, wait) &#123;</span><br><span class="line">   let lastTime = null　　　　<span class="comment">// 为了避免每次调用lastTime都被清空，利用闭包返回一个function确保不声明全局变量也可以</span></span><br><span class="line">   <span class="keyword">return</span> function () &#123;</span><br><span class="line">    let now = new Date()</span><br><span class="line">    <span class="comment">// 如果上次执行的时间和这次触发的时间大于一个执行周期，则执行</span></span><br><span class="line">    <span class="keyword">if</span> (now - lastTime - wait &gt; <span class="number">0</span>) &#123;</span><br><span class="line">     func()</span><br><span class="line">     lastTime = now</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>接下来就是调用了</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let throttleRun = throttle(() =&gt; &#123;</span><br><span class="line">  console.log(<span class="number">123</span>)</span><br><span class="line">&#125;, <span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">window.addEventListener('scroll', throttleRun)</span><br></pre></td></tr></table></figure><p>这时候疯狂的滚动页面，会发现会400ms打印一个123，而没有节流的话会不断地打印。</p><p>但是到这里，我们的节流方法是不完善的，因为我们的方法没有获取事件发生时的this对象，而且由于我们的方法简单粗暴的通过判断这次触发的时间和上次执行时间的间隔来决定是否执行回调，这样就会造成最后一次触发无法执行，或者用户触发的间隔确实很短，也无法执行，造成了误杀，所以需要对方法进行完善。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> function throttle(func, wait) &#123;</span><br><span class="line">    let lastTime = null</span><br><span class="line">    let timeout</span><br><span class="line">    <span class="keyword">return</span> function () &#123;</span><br><span class="line">        let context = <span class="keyword">this</span>;</span><br><span class="line">        let now = new Date();</span><br><span class="line">        let arg = arguments;</span><br><span class="line">        <span class="comment">// 如果上次执行的时间和这次触发的时间大于一个执行周期，则执行</span></span><br><span class="line">        <span class="keyword">if</span> (now - lastTime - wait &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果之前有了定时任务则清除</span></span><br><span class="line">            <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">                clearTimeout(timeout)</span><br><span class="line">                timeout = null</span><br><span class="line">            &#125;</span><br><span class="line">            func.apply(context, arg)</span><br><span class="line">            lastTime = now</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">            timeout = setTimeout(() =&gt; &#123;</span><br><span class="line">                <span class="comment">// 改变执行上下文环境</span></span><br><span class="line">                func.apply(context, arg)</span><br><span class="line">            &#125;, wait)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们的方法就相对完善了，调用方法和之前相同。</p><h2 id="debounce的实现"><a href="#debounce的实现" class="headerlink" title="debounce的实现"></a>debounce的实现</h2><p>去抖的方法，和节流思路一致，但是只有在动作被判定结束后，方法才会得到执行。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function debounce(method, delay) &#123;</span><br><span class="line">    var timer = null;</span><br><span class="line">    <span class="keyword">return</span> function () &#123;</span><br><span class="line">        var context = <span class="keyword">this</span>, args = arguments;</span><br><span class="line">        <span class="keyword">if</span>(timer)&#123;</span><br><span class="line">            clearTimeout(timer);</span><br><span class="line">            timer = null;</span><br><span class="line">        &#125; </span><br><span class="line">        timer = setTimeout(function () &#123;</span><br><span class="line">            method.apply(context, args);</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let debounceRun = debounce(() =&gt; &#123;</span><br><span class="line">        console.log('123');</span><br><span class="line">&#125;, <span class="number">600</span>);</span><br><span class="line">window.addEventListener('resize', debounceRun);</span><br></pre></td></tr></table></figure><p>调用方法和之前相同。</p><p>如有错误，欢迎指正！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在js中，我们经常会遇到这种情况，需要监听页面的scroll事件或者鼠标的mousemove事件等。由于这些事件在鼠标移动的过程中会被浏览器频繁的触发，会导致对应的事件也会被频繁的触发，这样就会造成很大的浏览器资源开销，而且好多中间的处理是不必要的，这样就会造成浏览器卡顿的现象。我们无法做到让浏览器不去触发对应的事件，但是可以做到让处理事件的方法执行频率减少（throttle）或者在执行动作完成后执行一次（debounce），从而减少对应的处理开销。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="javaScript" scheme="http://kursaal.vip/categories/javaScript/"/>
    
    
      <category term="throttle" scheme="http://kursaal.vip/tags/throttle/"/>
    
      <category term="debounce" scheme="http://kursaal.vip/tags/debounce/"/>
    
  </entry>
  
  <entry>
    <title>VSCode好用的插件</title>
    <link href="http://kursaal.vip/2017/06/26/VScode%E5%A5%BD%E7%94%A8%E7%9A%84%E6%8F%92%E4%BB%B6/"/>
    <id>http://kursaal.vip/2017/06/26/VScode好用的插件/</id>
    <published>2017-06-26T09:21:32.000Z</published>
    <updated>2019-08-05T02:36:59.890Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Open-In-Browser"><a href="#Open-In-Browser" class="headerlink" title="Open-In-Browser"></a>Open-In-Browser</h4><p>由于 VSCode 没有提供直接在浏览器中打开文件的内置界面，所以此插件在快捷菜单中添加了在默认浏览器查看文件选项，以及在客户端（Firefox，Chrome，IE）中打开命令面板选项。<br><a id="more"></a></p><h4 id="vscode-icon"><a href="#vscode-icon" class="headerlink" title="vscode-icon"></a>vscode-icon</h4><p>让  VSCode 资源树目录加上图标，必备良品！</p><h4 id="Path-Intellisense"><a href="#Path-Intellisense" class="headerlink" title="Path Intellisense"></a>Path Intellisense</h4><p>自动路劲补全，默认不带这个功能的</p><h4 id="beautify"><a href="#beautify" class="headerlink" title="beautify"></a>beautify</h4><p>Beautify css/sass/scss/less<br>react-beautify<br>格式化代码<br>使用指南：按F1,然后输入bea—&gt;选择你要格式的文件类型 js/css/html</p><h4 id="Bracket-Pair-Colorizer"><a href="#Bracket-Pair-Colorizer" class="headerlink" title="Bracket Pair Colorizer"></a>Bracket Pair Colorizer</h4><p>让括号拥有独立的颜色，易于区分。可以配合任意主题使用。</p><h4 id="Auto-Close-Tag"><a href="#Auto-Close-Tag" class="headerlink" title="Auto Close Tag"></a>Auto Close Tag</h4><p>自动闭合HTML标签</p><h4 id="Auto-rename-tag"><a href="#Auto-rename-tag" class="headerlink" title="Auto rename tag"></a>Auto rename tag</h4><p>更改HTML/XML标签名时，自动更新相对应的开始标签或结束标签的标签名</p><h4 id="Color-Info"><a href="#Color-Info" class="headerlink" title="Color Info"></a>Color Info</h4><p>这个便捷的插件，将为你提供你在 CSS 中使用颜色的相关信息。你只需在颜色上悬停光标，就可以预览色块中色彩模型的（HEX、 RGB、HSL 和 CMYK）相关信息了。</p><h4 id="HTML-Snippets"><a href="#HTML-Snippets" class="headerlink" title="HTML Snippets"></a>HTML Snippets</h4><p>超级实用且初级的 H5代码片段以及提示</p><h4 id="HTML-CSS-Support"><a href="#HTML-CSS-Support" class="headerlink" title="HTML CSS Support"></a>HTML CSS Support</h4><p>让 html 标签上写class 智能提示当前项目所支持的样式</p><h4 id="jQuery-Code-Snippets"><a href="#jQuery-Code-Snippets" class="headerlink" title="jQuery Code Snippets"></a>jQuery Code Snippets</h4><p>jquery 重度患者必须品，废话不多说，上图：<img src="https://img-blog.csdnimg.cn/20190805102522775.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1poYW5neGlhb3J1aV85,size_16,color_FFFFFF,t_70" alt="image"></p><h4 id="HTMLHint"><a href="#HTMLHint" class="headerlink" title="HTMLHint"></a>HTMLHint</h4><p>html代码检测</p><h4 id="CSS-Peek"><a href="#CSS-Peek" class="headerlink" title="CSS Peek"></a>CSS Peek</h4><p>使用此插件，你可以追踪至样式表中 CSS 类和 ids 定义的地方。当你在 HTML 文件中右键单击选择器时，选择“ Go to Definition 和 Peek definition ”选项，它便会给你发送样式设置的 CSS 代码。</p><h4 id="vetur"><a href="#vetur" class="headerlink" title="vetur"></a>vetur</h4><p>VUE —— 语法高亮、智能感知、Emmet等</p><h4 id="VueHelper"><a href="#VueHelper" class="headerlink" title="VueHelper"></a>VueHelper</h4><p>VUE —— snippet代码片段</p><h4 id="filesize"><a href="#filesize" class="headerlink" title="filesize"></a>filesize</h4><p>会在左下角显示文件大小，很不错</p><h4 id="Debugger-for-Chrome"><a href="#Debugger-for-Chrome" class="headerlink" title="Debugger for Chrome"></a>Debugger for Chrome</h4><h4 id="Preview"><a href="#Preview" class="headerlink" title="Preview"></a>Preview</h4><p>按F1,输入open preview to the side</p><h4 id="设置自动换行"><a href="#设置自动换行" class="headerlink" title="设置自动换行"></a>设置自动换行</h4><p>设置 – 用户设置 – 添加”editor.wordWrap”: “on” </p><h4 id="fileheader"><a href="#fileheader" class="headerlink" title="fileheader"></a>fileheader</h4><p>可以给文件自动加上头部说明信息<br>设置 – 用户设置 – 添加 ：<br>  “fileheader.Author”: “your name”,<br>  “fileheader.LastModifiedBy”: “your name”<br>使用方式：在文件中按alt + ctr + i，mac按option + control + i</p><h4 id="让空格显示为点"><a href="#让空格显示为点" class="headerlink" title="让空格显示为点"></a>让空格显示为点</h4><p>设置 – 用户设置 – 添加 ：”editor.renderWhitespace”: “all”</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Open-In-Browser&quot;&gt;&lt;a href=&quot;#Open-In-Browser&quot; class=&quot;headerlink&quot; title=&quot;Open-In-Browser&quot;&gt;&lt;/a&gt;Open-In-Browser&lt;/h4&gt;&lt;p&gt;由于 VSCode 没有提供直接在浏览器中打开文件的内置界面，所以此插件在快捷菜单中添加了在默认浏览器查看文件选项，以及在客户端（Firefox，Chrome，IE）中打开命令面板选项。&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="http://kursaal.vip/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="VSCode插件" scheme="http://kursaal.vip/tags/VSCode%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>查找数组中某个元素出现的所有下标</title>
    <link href="http://kursaal.vip/2017/06/12/%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0%E5%87%BA%E7%8E%B0%E7%9A%84%E6%89%80%E6%9C%89%E4%B8%8B%E6%A0%87/"/>
    <id>http://kursaal.vip/2017/06/12/查找数组中某个元素出现的所有下标/</id>
    <published>2017-06-12T01:25:16.000Z</published>
    <updated>2019-04-12T06:29:10.136Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前几天在工作中遇到一个需求，需要在一个url中截取第二个’/‘开始后面的字符，于是就需要获取到第二个’/‘的小标。如何在字符串中获取某个字符第n次出现的下标呢？用此文记录一下。<br><a id="more"></a></p><h4 id="获取字符串中某字符第n次出现的下标"><a href="#获取字符串中某字符第n次出现的下标" class="headerlink" title="获取字符串中某字符第n次出现的下标"></a>获取字符串中某字符第n次出现的下标</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function find(str, cha, num) &#123;</span><br><span class="line">  let index = str.indexOf(cha)</span><br><span class="line">  for (let i = 0;i &lt; num; i ++) &#123;</span><br><span class="line">    index = str.indexOf(cha, index+1) // 第二个参数为查找的起始位置</span><br><span class="line">  &#125;</span><br><span class="line">  return index</span><br><span class="line">&#125;</span><br><span class="line">var str = &apos;-a-b--c-f&apos;</span><br><span class="line">console.log(find(str,&apos;-&apos;, 2)) // 第三次出现的下标</span><br></pre></td></tr></table></figure><h4 id="查找数组中某个元素出现的所有下标"><a href="#查找数组中某个元素出现的所有下标" class="headerlink" title="查找数组中某个元素出现的所有下标"></a>查找数组中某个元素出现的所有下标</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function find(arr, cha) &#123;</span><br><span class="line">  const indexArr = []</span><br><span class="line">  let index = arr.indexOf(cha)</span><br><span class="line">  // 第一种方法</span><br><span class="line">  // while (index !== -1) &#123;</span><br><span class="line">  //   indexArr.push(index)</span><br><span class="line">  //   index = arr.indexOf(cha, index + 1)</span><br><span class="line">  // &#125;</span><br><span class="line"></span><br><span class="line">  // 第二种方法</span><br><span class="line">  for (let i = 0; i &lt; arr.length; i ++) &#123;</span><br><span class="line">    if (index === -1) break // 如果找不到，跳出循环</span><br><span class="line">    indexArr.push(index)</span><br><span class="line">    index = arr.indexOf(cha, index + 1)</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  return indexArr</span><br><span class="line">&#125;</span><br><span class="line">const arr = [&quot;Banana&quot;,&quot;Orange&quot;,&quot;Apple&quot;,&quot;Mango&quot;,&quot;Banana&quot;,&quot;Orange&quot;,&quot;Apple&quot;]</span><br><span class="line">console.log(find(arr, &apos;Banana&apos;)) // [0, 4]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;前几天在工作中遇到一个需求，需要在一个url中截取第二个’/‘开始后面的字符，于是就需要获取到第二个’/‘的小标。如何在字符串中获取某个字符第n次出现的下标呢？用此文记录一下。&lt;br&gt;
    
    </summary>
    
      <category term="javaScript" scheme="http://kursaal.vip/categories/javaScript/"/>
    
    
      <category term="下标" scheme="http://kursaal.vip/tags/%E4%B8%8B%E6%A0%87/"/>
    
  </entry>
  
  <entry>
    <title>图片懒加载的简单实现</title>
    <link href="http://kursaal.vip/2017/05/25/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://kursaal.vip/2017/05/25/图片懒加载的简单实现/</id>
    <published>2017-05-25T12:43:03.000Z</published>
    <updated>2019-03-05T07:30:06.046Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要使用懒加载"><a href="#为什么要使用懒加载" class="headerlink" title="为什么要使用懒加载"></a>为什么要使用懒加载</h2><p>在网页中，我们有时候需要展示多张图片。如果图片太多，页面的加载速度会慢很多，这样会非常影响用户体验。所以，在图片过多的页面，为了加速页面的加载进度，我们需要将页面中没出现在可视区域内的图片先不做加载，等图片滚动到可视区域内时，再把图片加载出来，这样对于页面的加载性能会有很大的提升。<br><a id="more"></a></p><h2 id="懒加载的原理"><a href="#懒加载的原理" class="headerlink" title="懒加载的原理"></a>懒加载的原理</h2><p>将页面中所有img标签的src统一设置为一张占位图进行占位，然后给每个img标签添加一个属性data-src（这个属性可以自定义）指向图片的真实地址。</p><p>当载入页面时，先把可视区域内的img标签的data-src属性值赋给src属性。然后监听滚动事件，当img标签出现在可视区域时，把data-src属性值赋给src属性。</p><p>这样，便实现了懒加载。</p><h2 id="懒加载的实现"><a href="#懒加载的实现" class="headerlink" title="懒加载的实现"></a>懒加载的实现</h2><p>直接上代码。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;img src=<span class="string">"frngji01(3).png"</span> data-src=<span class="string">"http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg"</span> alt=<span class="string">""</span>&gt;</span><br><span class="line">    &lt;img src=<span class="string">"frngji01(3).png"</span> data-src=<span class="string">"http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg"</span> alt=<span class="string">""</span>&gt;</span><br><span class="line">    &lt;img src=<span class="string">"frngji01(3).png"</span> data-src=<span class="string">"http://ww1.sinaimg.cn/large/006y8mN6gw1fa7kaed2hpj30sg0l9q54.jpg"</span> alt=<span class="string">""</span>&gt;</span><br><span class="line">    &lt;img src=<span class="string">"frngji01(3).png"</span> data-src=<span class="string">"http://ww1.sinaimg.cn/large/006y8mN6gw1fa7kaed2hpj30sg0l9q54.jpg"</span> alt=<span class="string">""</span>&gt;</span><br><span class="line">    &lt;img src=<span class="string">"frngji01(3).png"</span> data-src=<span class="string">"http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg"</span> alt=<span class="string">""</span>&gt;</span><br><span class="line">    &lt;img src=<span class="string">"frngji01(3).png"</span> data-src=<span class="string">"http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg"</span> alt=<span class="string">""</span>&gt;</span><br><span class="line">    &lt;img src=<span class="string">"frngji01(3).png"</span> data-src=<span class="string">"http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg"</span> alt=<span class="string">""</span>&gt;</span><br><span class="line">    &lt;img src=<span class="string">"frngji01(3).png"</span> data-src=<span class="string">"http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg"</span> alt=<span class="string">""</span>&gt;</span><br><span class="line">    &lt;img src=<span class="string">"frngji01(3).png"</span> data-src=<span class="string">"http://ww1.sinaimg.cn/large/006y8mN6gw1fa7kaed2hpj30sg0l9q54.jpg"</span> alt=<span class="string">""</span>&gt;</span><br><span class="line">    &lt;img src=<span class="string">"frngji01(3).png"</span> data-src=<span class="string">"http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg"</span> alt=<span class="string">""</span>&gt;</span><br><span class="line">    &lt;img src=<span class="string">"frngji01(3).png"</span> data-src=<span class="string">"http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg"</span> alt=<span class="string">""</span>&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>上面为html部分，是一些图片。  </p><p>接下来，我们给img标签加一些样式。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">img &#123;</span><br><span class="line">            display: block;</span><br><span class="line">            margin-bottom: <span class="number">50</span>px;</span><br><span class="line">            width: <span class="number">400</span>px;</span><br><span class="line">            height: <span class="number">400</span>px;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>现在，页面中就有一些一列排的占位图片。</p><p>接下来，就来实现懒加载。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function lazyload()&#123;</span><br><span class="line">    let n = <span class="number">0</span>; <span class="comment">//存储图片加载到的位置，避免每次都从第一张图片开始遍历</span></span><br><span class="line">    <span class="keyword">return</span> function () &#123; </span><br><span class="line">        let num = document.getElementsByTagName('img').length,//获取图片的个数</span><br><span class="line">            img = document.getElementsByTagName(<span class="string">"img"</span>),</span><br><span class="line">            seeHeight = document.documentElement.clientHeight || document.body.clientHeight, <span class="comment">//可见区域高度</span></span><br><span class="line">            scrollTop = document.documentElement.scrollTop || document.body.scrollTop; <span class="comment">//滚动条距离顶部高度</span></span><br><span class="line">        <span class="keyword">for</span> (let i = n; i &lt; num; i++) &#123;</span><br><span class="line">            <span class="comment">//判断图片是否进入可视区域</span></span><br><span class="line">            <span class="keyword">if</span> (img[i].offsetTop &lt; seeHeight + scrollTop) &#123;</span><br><span class="line">                <span class="keyword">if</span> (img[i].getAttribute(<span class="string">"src"</span>) == <span class="string">"frngji01(3).png"</span>) &#123;</span><br><span class="line">                    img[i].src = img[i].getAttribute(<span class="string">"data-src"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                n = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就实现了懒加载的基本逻辑。<br>接下来我们需要在页面刚开始加载时，就把可视区域的图片加载出来。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let lazyInit = lazyload();</span><br><span class="line">lazyInit();<span class="comment">//页面载入完毕加载可试区域内的图片</span></span><br></pre></td></tr></table></figure><p>然后，我们监听页面的滚动事件。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener('scroll', lazyInit);</span><br></pre></td></tr></table></figure><p>但到这里，我们的懒加载是不完善的。<br>在<a href="https://kursaal.vip/2018/04/22/js%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%EF%BC%88throttle%EF%BC%89%E5%92%8C%E5%87%BD%E6%95%B0%E5%8E%BB%E6%8A%96%EF%BC%88debounce%EF%BC%89/">js中的函数节流（throttle）和函数去抖（debounce）</a>中说过，当需要监听scroll事件时，我们一般会使用throttle节流方法。</p><p>接下来，我们就来完善一下我们的代码。</p><p>首先，先定义一个节流的函数。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function throttle(func, wait) &#123;</span><br><span class="line">        <span class="comment">// 为了避免每次调用lastTime都被清空，利用闭包返回一个function确保不声明全局变量也可以</span></span><br><span class="line">        let lastTime = null</span><br><span class="line">        let timeout</span><br><span class="line">        <span class="keyword">return</span> function () &#123;</span><br><span class="line">            let context = <span class="keyword">this</span>;</span><br><span class="line">            let now = new Date();</span><br><span class="line">            let arg = arguments;</span><br><span class="line">            <span class="comment">// 如果上次执行的时间和这次触发的时间大于一个执行周期，则执行</span></span><br><span class="line">            <span class="keyword">if</span> (now - lastTime - wait &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果之前有了定时任务则清除</span></span><br><span class="line">                <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">                    clearTimeout(timeout)</span><br><span class="line">                    timeout = null</span><br><span class="line">                &#125;</span><br><span class="line">                func.apply(context, arg)</span><br><span class="line">                lastTime = now</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">                timeout = setTimeout(() =&gt; &#123;</span><br><span class="line">                    <span class="comment">// 改变执行上下文环境</span></span><br><span class="line">                    func.apply(context, arg)</span><br><span class="line">                &#125;, wait)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，再调用节流的方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let lazyScroll = throttle(lazyInit, <span class="number">800</span>);</span><br></pre></td></tr></table></figure><p>最后，我们修改scroll事件的回调方法为lazyScroll。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener('scroll', lazyScroll);</span><br></pre></td></tr></table></figure><p>到这里，我们就实现了一个简单的懒加载。</p><p>如有错误，欢迎指正！</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/24057749" target="_blank" rel="noopener">前端如何实现图片懒加载(lazyload) 提高用户体验</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么要使用懒加载&quot;&gt;&lt;a href=&quot;#为什么要使用懒加载&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用懒加载&quot;&gt;&lt;/a&gt;为什么要使用懒加载&lt;/h2&gt;&lt;p&gt;在网页中，我们有时候需要展示多张图片。如果图片太多，页面的加载速度会慢很多，这样会非常影响用户体验。所以，在图片过多的页面，为了加速页面的加载进度，我们需要将页面中没出现在可视区域内的图片先不做加载，等图片滚动到可视区域内时，再把图片加载出来，这样对于页面的加载性能会有很大的提升。&lt;br&gt;
    
    </summary>
    
      <category term="javaScript" scheme="http://kursaal.vip/categories/javaScript/"/>
    
    
      <category term="懒加载" scheme="http://kursaal.vip/tags/%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>移动端点击（click）事件延迟问题的产生与解决方法</title>
    <link href="http://kursaal.vip/2017/05/13/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%82%B9%E5%87%BB%EF%BC%88click%EF%BC%89%E4%BA%8B%E4%BB%B6%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98%E7%9A%84%E4%BA%A7%E7%94%9F%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://kursaal.vip/2017/05/13/移动端点击（click）事件延迟问题的产生与解决方法/</id>
    <published>2017-05-13T08:59:15.000Z</published>
    <updated>2019-04-15T09:56:49.114Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么会存在300ms延迟？"><a href="#为什么会存在300ms延迟？" class="headerlink" title="为什么会存在300ms延迟？"></a>为什么会存在300ms延迟？</h3><p>移动浏览器为什么会设置300毫秒的等待时间呢？这与双击缩放的方案有关。平时我们可能已经注意到了，双击缩放，即用手指在屏幕上快速点击两次，可以看到内容或者图片放大，再次双击，浏览器会将网页缩放至原始比例。<br><a id="more"></a> </p><p>浏览器捕获第一次单击后，会先等待一段时间，如果在这段时间区间里用户未进行下一次点击，浏览器会做单击事件的处理。如果这段时间里用户进行了第二次单击操作，则浏览器会做缩放处理。这段时间就是移动端点击事件的300ms延迟。</p><h3 id="如何避免延迟？"><a href="#如何避免延迟？" class="headerlink" title="如何避免延迟？"></a>如何避免延迟？</h3><h4 id="方法一：禁止缩放"><a href="#方法一：禁止缩放" class="headerlink" title="方法一：禁止缩放"></a>方法一：禁止缩放</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name = &quot;viewport&quot; content=&quot;user-scalable=no&quot; &gt;</span><br></pre></td></tr></table></figure><p>使用这个方法是通过完全禁用缩放来达到目的，虽然大部分移动端能解决这个延迟问题，但是部分苹果手机还是不行。</p><h4 id="方法二：fastclick-js"><a href="#方法二：fastclick-js" class="headerlink" title="方法二：fastclick.js"></a>方法二：fastclick.js</h4><p>FastClick 是 FT Labs 专门为解决移动端浏览器 300 ms点击延迟问题所开发的一个轻量级的库。简而言之，FastClick 在检测到touchend事件的时候，会通过 DOM 自定义事件立即触发一个模拟click事件，并把浏览器在 300 ms之后真正触发的click事件阻止掉。使用方法如下：</p><p>第一步：在页面中引入fastclick.js文件；  </p><p>第二步：在js文件中添加以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 原生js写法</span><br><span class="line">if (&apos;addEventListener&apos; in document) &#123;</span><br><span class="line">    document.addEventListener(&apos;DOMContentLoaded&apos;, function() &#123;</span><br><span class="line">        // 参数可以是任意的dom元素，如果写document.body，说明会将document.body下面的所的元素都绑定fastclick</span><br><span class="line">        FastClick.attach(documen.body)</span><br><span class="line">    &#125;, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// jQuery写法</span><br><span class="line">$(function() &#123;</span><br><span class="line">    FastClick.attach(document.body);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 在vue中的使用方法</span><br><span class="line">// 安装</span><br><span class="line">npm install fastclick -S</span><br><span class="line"></span><br><span class="line">// 引入</span><br><span class="line">import FastClick from &apos;fastclick&apos;</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">FastClick.attach(document.body);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;为什么会存在300ms延迟？&quot;&gt;&lt;a href=&quot;#为什么会存在300ms延迟？&quot; class=&quot;headerlink&quot; title=&quot;为什么会存在300ms延迟？&quot;&gt;&lt;/a&gt;为什么会存在300ms延迟？&lt;/h3&gt;&lt;p&gt;移动浏览器为什么会设置300毫秒的等待时间呢？这与双击缩放的方案有关。平时我们可能已经注意到了，双击缩放，即用手指在屏幕上快速点击两次，可以看到内容或者图片放大，再次双击，浏览器会将网页缩放至原始比例。&lt;br&gt;
    
    </summary>
    
      <category term="javaScript" scheme="http://kursaal.vip/categories/javaScript/"/>
    
    
      <category term="300ms延迟" scheme="http://kursaal.vip/tags/300ms%E5%BB%B6%E8%BF%9F/"/>
    
      <category term="fastclick" scheme="http://kursaal.vip/tags/fastclick/"/>
    
  </entry>
  
  <entry>
    <title>元素宽高成比例自适应</title>
    <link href="http://kursaal.vip/2017/04/11/%E5%85%83%E7%B4%A0%E5%AE%BD%E9%AB%98%E6%88%90%E6%AF%94%E4%BE%8B%E8%87%AA%E9%80%82%E5%BA%94/"/>
    <id>http://kursaal.vip/2017/04/11/元素宽高成比例自适应/</id>
    <published>2017-04-11T01:58:08.000Z</published>
    <updated>2019-04-11T02:00:20.805Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在开发过程中，我们经常会遇到让元素的宽高成一定比例的情况。或者在使用轮播图时，如果我们只是靠图片撑开元素的高度，那图片未加载出来时，页面会出现抖动的情况。为了避免这种情况，我们就需要让容器宽高成一定比例，如果图片是600*300的尺寸，我们就需要让容器的宽高比为2:1。<br><a id="more"></a></p><h3 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h3><p>我们可以使容器的宽度为100%，但高度不能使用50%，因为元素的高度是根据父元素的高度为基数的，并不是宽度。那我们这时候就需要用一点小技巧了，我们知道元素的padding值都是以父元素的宽度为基数的。那我们就可以这样实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 0; // 防止内容撑开高度</span><br><span class="line">    padding-bottom: 50%;</span><br><span class="line">    overflow:hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实代码很简单，主要是记录一下思路。</p><h3 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h3><p>还有另一种实现方式：使用vw，相对于视口的宽度，视口被均分为100单位的vw<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">    width:100vw;</span><br><span class="line">    height:50vw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是这种目前兼容性不是很好，所以如果需要兼容性好的话，还是使用第一种方法吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在开发过程中，我们经常会遇到让元素的宽高成一定比例的情况。或者在使用轮播图时，如果我们只是靠图片撑开元素的高度，那图片未加载出来时，页面会出现抖动的情况。为了避免这种情况，我们就需要让容器宽高成一定比例，如果图片是600*300的尺寸，我们就需要让容器的宽高比为2:1。&lt;br&gt;
    
    </summary>
    
      <category term="css" scheme="http://kursaal.vip/categories/css/"/>
    
    
      <category term="自适应" scheme="http://kursaal.vip/tags/%E8%87%AA%E9%80%82%E5%BA%94/"/>
    
  </entry>
  
  <entry>
    <title>圣杯布局</title>
    <link href="http://kursaal.vip/2017/04/02/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80/"/>
    <id>http://kursaal.vip/2017/04/02/圣杯布局/</id>
    <published>2017-04-02T02:32:35.000Z</published>
    <updated>2019-03-21T02:39:27.947Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在上一篇实现了双飞翼布局，这篇来实现一下圣杯布局。圣杯布局和双飞翼实现的效果是一样的，都是三栏布局，两侧栏宽度固定，中间栏自适应并且能在浏览器中优先展示渲染。</p></blockquote><a id="more"></a><h2 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h2><p>废话不多说，直接上代码吧。</p><p>首先，先给出页面结构，在三栏外面套一个容器，如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;center col&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;left col&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;right col&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p><p>上面就是我们第一步的页面结构，把center写在第一个是为了实现在浏览器优先渲染。</p><p>然后，开始写样式，首先给三栏写上基本样式如下,高度都为400px：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.col&#123;</span><br><span class="line">    height:400px;</span><br><span class="line">&#125;</span><br><span class="line">.center&#123;</span><br><span class="line">    width:100%;</span><br><span class="line">    background:red;</span><br><span class="line">&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">    width:200px;</span><br><span class="line">    background:green;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">    width:200px;</span><br><span class="line">    background:blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到这里，我们三栏的基本样式就出来了。此时，三栏并不在一行，那块级元素怎么才能一行显示呢？那就是通过浮动。所以，我们再加上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.col&#123;</span><br><span class="line">    height: 400px;</span><br><span class="line">    float: left;//新增</span><br><span class="line">&#125;</span><br><span class="line">.center&#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    background: red;</span><br><span class="line">&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    background: green;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    background: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这时候center的宽度是占满屏幕的，那这样才能让它在中间呢？这时给外层的container加上样式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">    padding: 0 200px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这时候，已经实现了三栏都在中间，但由于center宽度为100%，左右两栏被挤到了第二行，这时，就需要用上负边距来使三栏在同一行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">    padding: 0 200px;</span><br><span class="line">&#125;</span><br><span class="line">.col&#123;</span><br><span class="line">    height: 400px;</span><br><span class="line">    float: left;</span><br><span class="line">&#125;</span><br><span class="line">.center&#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    background: red;</span><br><span class="line">&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    background: green;</span><br><span class="line">    margin-left: -100%; // 新增</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    background: blue;</span><br><span class="line">    margin-left: -200px; // 新增</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到这里，三栏已经在同一行了，但三栏现在都是在中间，怎么让左右两栏位于两侧呢？这时我们就需要给左右两栏加上相对定位来改变他们自身的位置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">    padding: 0 200px;</span><br><span class="line">&#125;</span><br><span class="line">.col&#123;</span><br><span class="line">    height: 400px;</span><br><span class="line">    float: left;</span><br><span class="line">&#125;</span><br><span class="line">.center&#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    background: red;</span><br><span class="line">&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    background: green;</span><br><span class="line">    margin-left: -100%;</span><br><span class="line">    position: relative; // 新增</span><br><span class="line">    left: -200px; // 新增</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    background: blue;</span><br><span class="line">    margin-left: -200px;</span><br><span class="line">    position: relative; // 新增</span><br><span class="line">    left: 200px; // 新增</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>至此，我们就实现了圣杯布局！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在上一篇实现了双飞翼布局，这篇来实现一下圣杯布局。圣杯布局和双飞翼实现的效果是一样的，都是三栏布局，两侧栏宽度固定，中间栏自适应并且能在浏览器中优先展示渲染。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="css" scheme="http://kursaal.vip/categories/css/"/>
    
    
      <category term="圣杯布局" scheme="http://kursaal.vip/tags/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>双飞翼布局</title>
    <link href="http://kursaal.vip/2017/04/01/%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/"/>
    <id>http://kursaal.vip/2017/04/01/双飞翼布局/</id>
    <published>2017-04-01T11:48:17.000Z</published>
    <updated>2019-03-05T07:30:06.045Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>双飞翼布局和圣杯布局，都是三栏布局，两侧栏宽度固定，中间栏自适应并且能在浏览器中优先展示渲染。它们实现的效果是一样的，差别在于其实现的思想。</p></blockquote><a id="more"></a><p>既然了解了这两种布局的功能，接下来我们就来看看具体怎么实现吧。文章中的两种方式都是兼容目前所有的主流浏览器，包括IE6在内；所以是不使用‘box-sizing’属性的。第一个先看看双飞翼布局。</p><h2 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h2><p>首先，先给出页面结构，在三栏外面套一个容器，如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;center col&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;left col&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;right col&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p><p>上面就是我们第一步的页面结构，把center写在第一个是为了实现在浏览器优先渲染。</p><p>接下来我们先给三栏各自设置宽高，这里我们高度都用400px。因为中间栏宽度要自适应，所以我们设置为100%。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.col&#123;</span><br><span class="line">    height:400px;</span><br><span class="line">&#125;</span><br><span class="line">.center&#123;</span><br><span class="line">    width:100%;</span><br><span class="line">    background:red;</span><br><span class="line">&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">    width:200px;</span><br><span class="line">    background:green;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">    width:200px;</span><br><span class="line">    background:blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到这里，我们三栏的基本样式就出来了。此时，三栏并不在一行，那块级元素怎么才能一行显示呢？那就是通过浮动。所以，我们再加上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.col&#123;</span><br><span class="line">    height:400px;</span><br><span class="line">    float:left;//新增</span><br><span class="line">&#125;</span><br><span class="line">.center&#123;</span><br><span class="line">    width:100%;</span><br><span class="line">    background:red;</span><br><span class="line">&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">    width:200px;</span><br><span class="line">    background:green;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">    width:200px;</span><br><span class="line">    background:blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>浮动的特点就是这一行占满了就会换行。因为中间栏已经占满了一行，所以此时两侧栏是在第二行的。那怎么才能让两个侧栏上来呢？这就是负外边距的作用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.col&#123;</span><br><span class="line">    height:400px;</span><br><span class="line">    float:left;</span><br><span class="line">&#125;</span><br><span class="line">.center&#123;</span><br><span class="line">    width:100%;</span><br><span class="line">    background:red;</span><br><span class="line">&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">    width:200px;</span><br><span class="line">    background:green;</span><br><span class="line">    //此处的100%是相对于父元素的，在此处也就是center的宽度</span><br><span class="line">    margin-left:-100%;//新增</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">    width:200px;</span><br><span class="line">    background:blue;</span><br><span class="line">    //此处的200px是自身的宽度</span><br><span class="line">    margin-left：-200px;//新增</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，三栏的基本布局就已经完成了。但是还有个问题，就是当我们在center中加入内容后，两边的内容会被两侧栏挡住，前面我们说了为了兼容性，我们是不使用box-sizing属性的，所以不能直接给center加padding属性。这里不理解的可以参考我另一篇文章：<a href="https://kursaal.vip/2017/01/16/%E5%85%B3%E4%BA%8E%E7%9B%92%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3/">关于盒模型的理解</a></p><p>这时我们可以在center中新增一个子元素用来放置中间的内容，同时让它的左右外边距为左右两栏的宽度：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;center col&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;//新增</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;left col&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;right col&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.col &#123;</span><br><span class="line">    height: 400px;</span><br><span class="line">    float: left;</span><br><span class="line">&#125;</span><br><span class="line">.center &#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    background: red;</span><br><span class="line">&#125;</span><br><span class="line">.left &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    background: green; </span><br><span class="line">    margin-left: -100%; </span><br><span class="line">&#125;</span><br><span class="line">.right &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    background: blue; </span><br><span class="line">    margin-left:-200px;</span><br><span class="line">&#125;</span><br><span class="line">.main&#123;</span><br><span class="line">    margin:0 200px;//新增</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们就实现了双飞翼布局。须注意一点：因为两侧栏宽度是一定的，中间自适应，这样如果宽度缩小到一定程度中间的内容就会乱，所以一般我们都会给body加上min-width属性。</p><p>圣杯布局，下篇文章再见吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;双飞翼布局和圣杯布局，都是三栏布局，两侧栏宽度固定，中间栏自适应并且能在浏览器中优先展示渲染。它们实现的效果是一样的，差别在于其实现的思想。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="css" scheme="http://kursaal.vip/categories/css/"/>
    
    
      <category term="双飞翼布局" scheme="http://kursaal.vip/tags/%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>关于函数重载和arguments</title>
    <link href="http://kursaal.vip/2017/03/24/%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E5%92%8Carguments/"/>
    <id>http://kursaal.vip/2017/03/24/关于函数重载和arguments/</id>
    <published>2017-03-24T11:12:35.000Z</published>
    <updated>2019-04-18T02:26:02.314Z</updated>
    
    <content type="html"><![CDATA[<h4 id="重载的概念"><a href="#重载的概念" class="headerlink" title="重载的概念"></a>重载的概念</h4><p>重载，简单说，就是函数或者方法有相同的名称，但是参数列表(包括参数个数和参数类型)不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。<br><a id="more"></a></p><h4 id="js中的函数重载"><a href="#js中的函数重载" class="headerlink" title="js中的函数重载"></a>js中的函数重载</h4><p>js中没有重载。就是说，js不允许有名字相同的函数，如果你声明了两个名字相同的函数，后一个就会覆盖掉前一个。<br>在js中，函数是作为一种特殊对象类型存在的，函数的名字只是一个普通的变量，本质与var a = 1中的变量a没什么区别。所以如果你先后定义了两个同名函数，实际上相当于先后将两个函数对象绑定到了同一个变量上，所以后者必然覆盖前者，不会共存，也自然不存在重载了。</p><h4 id="js中的arguments"><a href="#js中的arguments" class="headerlink" title="js中的arguments"></a>js中的arguments</h4><p>总所周知，js是一门相当灵活的语言。当我们在js中在调用一个函数的时候，我们经常会给这个函数传递一些参数，js把传入到这个函数的全部参数存储在一个叫做arguments的东西里面，那么这到底是什么东西？<br>在js中万物皆对象，甚至数组字符串函数都是对象。所以这个叫做arguments的东西也是个对象，而且是一个特殊的对象，它的属性名是按照传入参数的序列来的，第1个参数的属性名是’0’，第2个参数的属性名是’1’，以此类推，并且它还有length属性，存储的是当前传入函数参数的个数，很多时候我们把这种对象叫做类数组对象。关于类数组，此处不做详细讲解。<br>接下来我们来看看arguments对象里面到底有些什么东西，是骡子是马拉出来溜溜。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function showargs() &#123;</span><br><span class="line">    console.log( arguments );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showargs(1,2,3,4,5);</span><br></pre></td></tr></table></figure><p>打印结果：<br><img src="http://img.blog.csdn.net/20161119152524405" alt="image">  </p><p>这里我们可以看到arguments对象将我传入的五个参数以数组的形式保存在里面，还保存了我传入函数的实参的个数（length）。而且我们可以看到arguments对象的 _ proto _是指向object的，这也说明了他是个类数组对象，而不是一个数组。<br>有了这个对象我们以后写函数的时候，就不用给所有的形参指定参数名，然后通过参数名的方式获取参数了，我们可以直接使用arguments对象来获取实参，这样是不是方便了很多呢。<br>有些语言在我们给函数指定了参数名之后，当调用函数时，会判断当前传入的参数是否与函数定义的参数个数相等，不相等就会报错。但是灵活的js并不会验证传递给函数的参数个数是否等于函数定义的参数个数。所以代码的简洁度（为了装逼），我们使用arguments调用参数可以不混淆不同函数之间的参数名。另外代码的严整度（为了装逼），我们也能用arguments来判断当前传入参数的个数是否与我们需要的数量一致。<br>下面举个栗子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function add() &#123;</span><br><span class="line">    if( arguments.length == 2 )&#123;</span><br><span class="line">        return arguments[0] + arguments[1];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return &apos;传入参数不合法&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log( add(2,3) );</span><br><span class="line">console.log( add(1,2,3) );</span><br></pre></td></tr></table></figure></p><p>看看结果：<br><img src="http://img.blog.csdn.net/20161119154939672" alt="image"><br>最后我们还可以看到arguments还有一个叫做callee的属性，这个属性是表示的是当前函数的一个引用。简单点说，这个属性里面存储的是我们调用的这个函数的代码，实在无法理解的时候，又到了console.log大显身手的时候了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function showcallee() &#123;</span><br><span class="line">    var a = &apos;这里是代码&apos;;</span><br><span class="line">    var b = &apos;这是另一段代码&apos;;</span><br><span class="line">    var c = a + b;</span><br><span class="line">    console.log(arguments.callee);</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line">showcallee();</span><br></pre></td></tr></table></figure></p><p>看看结果：<br><img src="http://img.blog.csdn.net/20161119161029575" alt="image"><br>看到结果的你是不是和我一样惊呆了呢，这不就是我写的代码吗？arguments.callee完完整整的把这个函数的这段代码返回了。 </p><h4 id="arguments和函数重载的关系"><a href="#arguments和函数重载的关系" class="headerlink" title="arguments和函数重载的关系"></a>arguments和函数重载的关系</h4><p>上面说过了，由于js是一种弱类型的语言，没有重载机制，当我们重写函数时，会将原来的函数直接覆盖，这里我们能利用arguments，来判断传入的实参类型与数量进行不同的操作，然后返回不同的结果，来实现js中的函数重载。<br>举个栗子：<br>下面我们利用arguments对象来实现一个参数相加的函数，不论传入多少参数都行，将传入的参数相加后返回。 </p><pre><code>function add() {    let sum = 0;    for(const item of arguments){        sum += item;    }    return sum;}console.log(add(1, 2, 3));   //6console.log(add(1, 3));     //4console.log(add(1, 2, 3, 5, 6, 2, 7));   //26</code></pre><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="http://blog.csdn.net/qq_16339527/article/details/53231725" target="_blank" rel="noopener">js的arguments到底是什么？</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;重载的概念&quot;&gt;&lt;a href=&quot;#重载的概念&quot; class=&quot;headerlink&quot; title=&quot;重载的概念&quot;&gt;&lt;/a&gt;重载的概念&lt;/h4&gt;&lt;p&gt;重载，简单说，就是函数或者方法有相同的名称，但是参数列表(包括参数个数和参数类型)不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。&lt;br&gt;
    
    </summary>
    
      <category term="javaScript" scheme="http://kursaal.vip/categories/javaScript/"/>
    
    
      <category term="arguments" scheme="http://kursaal.vip/tags/arguments/"/>
    
      <category term="函数重载" scheme="http://kursaal.vip/tags/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>javaScript中this的用法</title>
    <link href="http://kursaal.vip/2017/03/11/this%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>http://kursaal.vip/2017/03/11/this的用法/</id>
    <published>2017-03-11T07:22:16.000Z</published>
    <updated>2019-03-05T07:30:06.040Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><blockquote><p>this是JavaScript中一个比较难理解的点，很多新人会很迷惑。本文非原创，是阮一峰老师个人博客里的，个人感觉理解起来会很容易。拿来与大家分享。<a href="http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html" target="_blank" rel="noopener">原文链接</a></p></blockquote><a id="more"></a><h4 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h4><p>this是Javascript语言的一个关键字。</p><p>它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。比如，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　function test()&#123;</span><br><span class="line"></span><br><span class="line">　　　　this.x = 1;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><p>随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，==调用函数的那个对象。==</p><hr><p>下面分四种情况，详细讨论this的用法。  </p><h5 id="情况一：纯粹的函数调用"><a href="#情况一：纯粹的函数调用" class="headerlink" title="情况一：纯粹的函数调用"></a>情况一：纯粹的函数调用</h5><p>这是函数的最通常用法，属于全局性调用，因此this就代表全局对象Global。</p><p>请看下面这段代码，它的运行结果是1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">　function test()&#123;</span><br><span class="line"></span><br><span class="line">　　　　this.x = 1;</span><br><span class="line"></span><br><span class="line">　　　　alert(this.x);</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　test(); // 1</span><br></pre></td></tr></table></figure></p><p>为了证明this就是全局对象，我对代码做一些改变：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">　　var x = 1;</span><br><span class="line"></span><br><span class="line">　　function test()&#123;</span><br><span class="line"></span><br><span class="line">　　　　alert(this.x);</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　test(); // 1</span><br></pre></td></tr></table></figure></p><p>运行结果还是1。再变一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">　var x = 1;</span><br><span class="line"></span><br><span class="line">　　function test()&#123;</span><br><span class="line"></span><br><span class="line">　　　　this.x = 0;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　test();</span><br><span class="line"></span><br><span class="line">　　alert(x); //0</span><br></pre></td></tr></table></figure><h5 id="情况二：作为对象方法的调用"><a href="#情况二：作为对象方法的调用" class="headerlink" title="情况二：作为对象方法的调用"></a>情况二：作为对象方法的调用</h5><p>函数还可以作为某个对象的方法调用，这时this就指这个上级对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">　function test()&#123;</span><br><span class="line"></span><br><span class="line">　　　　alert(this.x);</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　var o = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">　　o.x = 1;</span><br><span class="line"></span><br><span class="line">　　o.m = test;</span><br><span class="line"></span><br><span class="line">　　o.m(); // 1</span><br></pre></td></tr></table></figure><h5 id="情况三-：作为构造函数调用"><a href="#情况三-：作为构造函数调用" class="headerlink" title="情况三 ：作为构造函数调用"></a>情况三 ：作为构造函数调用</h5><p>所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this就指这个新对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">　function test()&#123;</span><br><span class="line"></span><br><span class="line">　　　　this.x = 1;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　var o = new test();</span><br><span class="line"></span><br><span class="line">　　alert(o.x); // 1</span><br></pre></td></tr></table></figure></p><p>运行结果为1。为了表明这时this不是全局对象，我对代码做一些改变：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">　　var x = 2;</span><br><span class="line"></span><br><span class="line">　　function test()&#123;</span><br><span class="line"></span><br><span class="line">　　　　this.x = 1;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　var o = new test();</span><br><span class="line"></span><br><span class="line">　　alert(x); //2</span><br></pre></td></tr></table></figure></p><p>运行结果为2，表明全局变量x的值根本没变。  </p><h5 id="情况四：-apply调用"><a href="#情况四：-apply调用" class="headerlink" title="情况四： apply调用"></a>情况四： apply调用</h5><p>apply()是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。因此，this指的就是这第一个参数。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">　　var x = 0;</span><br><span class="line"></span><br><span class="line">　　function test()&#123;</span><br><span class="line"></span><br><span class="line">　　　　alert(this.x);</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　var o=&#123;&#125;;</span><br><span class="line"></span><br><span class="line">　　o.x = 1;</span><br><span class="line"></span><br><span class="line">　　o.m = test;</span><br><span class="line"></span><br><span class="line">　　o.m.apply(); //0</span><br></pre></td></tr></table></figure><p>apply()的参数为空时，默认调用全局对象。因此，这时的运行结果为0，证明this指的是全局对象。</p><p>如果把最后一行代码修改为 : </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　o.m.apply(o); //1</span><br></pre></td></tr></table></figure><p>运行结果就变成了1，证明了这时this代表的是对象o。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;this是JavaScript中一个比较难理解的点，很多新人会很迷惑。本文非原创，是阮一峰老师个人博客里的，个人感觉理解起来会很容易。拿来与大家分享。&lt;a href=&quot;http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="javaScript" scheme="http://kursaal.vip/categories/javaScript/"/>
    
    
      <category term="this" scheme="http://kursaal.vip/tags/this/"/>
    
      <category term="js" scheme="http://kursaal.vip/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js中的深拷贝和浅拷贝</title>
    <link href="http://kursaal.vip/2017/03/01/js%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://kursaal.vip/2017/03/01/js中的深拷贝和浅拷贝/</id>
    <published>2017-03-01T07:18:23.000Z</published>
    <updated>2019-03-05T07:30:06.038Z</updated>
    
    <content type="html"><![CDATA[<h2 id="两者的概念和区别"><a href="#两者的概念和区别" class="headerlink" title="两者的概念和区别"></a>两者的概念和区别</h2><p>对于基本数据类型(Undefined、Null、String、Number、Boolean)，浅拷贝是对值的复制，改变其中一个的值另一个不会跟着改变。<a id="more"></a>对于对象来说，浅拷贝是对地址的复制，并没有开辟新的栈，也就是复制的结果是两个对象指向同一个地址，修改其中一个对象的属性，则另一个对象的属性也会改变；而深拷贝则是开辟新的栈，两个对象对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性。</p><h2 id="深拷贝的实现方式"><a href="#深拷贝的实现方式" class="headerlink" title="深拷贝的实现方式"></a>深拷贝的实现方式</h2><p>关于深拷贝的实现，网上也有很多方式了。在此我总结了几种我用的比较多的。</p><h3 id="方式一：递归拷贝"><a href="#方式一：递归拷贝" class="headerlink" title="方式一：递归拷贝"></a>方式一：递归拷贝</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function deepClone(obj,newObj) &#123;</span><br><span class="line">    if(typeof obj !== &apos;object&apos;)&#123;</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">    var newObj = newObj || &#123;&#125;;</span><br><span class="line">    for(var key in obj)&#123;</span><br><span class="line">        //首先判断是不是自身属性，如果不是，则跳过本次循环</span><br><span class="line">        if(!obj.hasOwnProperty(key))&#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if(typeof obj[key] === &apos;object&apos;)&#123;</span><br><span class="line">            //判断是数组还是对象</span><br><span class="line">            newObj[key] = Object.prototype.toString.call(obj[key]) === &apos;[object Array]&apos;?[]:&#123;&#125;;</span><br><span class="line">            deepClone(obj[key],newObj[key]);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            newObj[key] = obj[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方式二：jquery中-extent方法"><a href="#方式二：jquery中-extent方法" class="headerlink" title="方式二：jquery中$.extent方法"></a>方式二：jquery中$.extent方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var obj03 = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: &#123;</span><br><span class="line">        f: &#123;</span><br><span class="line">            g: 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    c: [1, 2, 3]</span><br><span class="line">&#125;;</span><br><span class="line">var obj04 = $.extend(true, &#123;&#125;, obj03);</span><br><span class="line">obj04.b.f = &#123;</span><br><span class="line">    k : 2</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj03.b.f === obj04.b.f); // false</span><br></pre></td></tr></table></figure><h3 id="方式三：JSON-parse方法"><a href="#方式三：JSON-parse方法" class="headerlink" title="方式三：JSON.parse方法"></a>方式三：JSON.parse方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    body: &#123;</span><br><span class="line">        a: 10</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var shallowClone = obj;</span><br><span class="line">var deepClone = JSON.parse(JSON.stringify(obj));</span><br><span class="line">console.log(shallowClone.body === obj.body);//true</span><br><span class="line">console.log(deepClone.body === obj.body);//false</span><br></pre></td></tr></table></figure><p>以上三种方式都可以实现对对象的深拷贝。</p><h3 id="对数组的深拷贝"><a href="#对数组的深拷贝" class="headerlink" title="对数组的深拷贝"></a>对数组的深拷贝</h3><p>对数组的深拷贝可以使用下面这种方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var ary = [&apos;one&apos;,&apos;two&apos;,&apos;three&apos;];</span><br><span class="line">var ary02 = ary.slice(0);</span><br><span class="line">ary02.push(&apos;four&apos;);</span><br><span class="line">console.log(ary);//[&apos;one&apos;,&apos;two&apos;,&apos;three&apos;]</span><br><span class="line">console.log(ary02);//[&apos;one&apos;,&apos;two&apos;,&apos;three&apos;,&apos;four&apos;]</span><br></pre></td></tr></table></figure></p><p>上面是个人的总结，如果错误，欢迎留言交流！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;两者的概念和区别&quot;&gt;&lt;a href=&quot;#两者的概念和区别&quot; class=&quot;headerlink&quot; title=&quot;两者的概念和区别&quot;&gt;&lt;/a&gt;两者的概念和区别&lt;/h2&gt;&lt;p&gt;对于基本数据类型(Undefined、Null、String、Number、Boolean)，浅拷贝是对值的复制，改变其中一个的值另一个不会跟着改变。
    
    </summary>
    
      <category term="javaScript" scheme="http://kursaal.vip/categories/javaScript/"/>
    
    
      <category term="深拷贝" scheme="http://kursaal.vip/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>not defined、undefined和null的区别</title>
    <link href="http://kursaal.vip/2017/02/24/not-defined%E3%80%81undefined%E5%92%8Cnull%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://kursaal.vip/2017/02/24/not-defined、undefined和null的区别/</id>
    <published>2017-02-24T06:11:40.000Z</published>
    <updated>2019-03-05T07:30:06.040Z</updated>
    
    <content type="html"><![CDATA[<h5 id="not-defined"><a href="#not-defined" class="headerlink" title="not defined"></a>not defined</h5><p>意为没有定义的变量。<br>例：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">console.log(m);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>上述代码中m没有被定义，此时浏览器会报错</p><blockquote><p>Uncaught ReferenceError: m is not defined  </p></blockquote><h5 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h5><p>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：  </p><ol><li>变量被声明了，但没有赋值时，就等于undefined。</li><li>调用函数时，应该提供的参数没有提供，该参数等于undefined。</li><li>对象没有赋值的属性，该属性的值为undefined。</li><li>函数没有返回值时，默认返回undefined。  </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var i;</span><br><span class="line">i // undefined</span><br><span class="line"></span><br><span class="line">function f(x)&#123;console.log(x)&#125;</span><br><span class="line">f() // undefined</span><br><span class="line"></span><br><span class="line">var  o = new Object();</span><br><span class="line">o.p // undefined</span><br><span class="line"></span><br><span class="line">var x = f();</span><br><span class="line">x // undefined</span><br></pre></td></tr></table></figure><p>上面四种情况执行结果一样：不会报错，会打印出undefined。  </p><h5 id="null"><a href="#null" class="headerlink" title="null"></a>null</h5><p>null表示 “没有对象”，即该处不应该有值。典型用法是：  </p><ol><li>作为函数的参数，表示该函数的参数不是对象。</li><li>作为对象原型链的终点。  </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.getPrototypeOf(Object.prototype)</span><br><span class="line">// null</span><br></pre></td></tr></table></figure><h5 id="需要注意"><a href="#需要注意" class="headerlink" title="需要注意"></a>需要注意</h5><p>这里需要注意的是：null == undefined结果是true的，null === undefined结果是false的。  </p><h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p><a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html" target="_blank" rel="noopener">阮一峰：undefined与null的区别</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;not-defined&quot;&gt;&lt;a href=&quot;#not-defined&quot; class=&quot;headerlink&quot; title=&quot;not defined&quot;&gt;&lt;/a&gt;not defined&lt;/h5&gt;&lt;p&gt;意为没有定义的变量。&lt;br&gt;例：&lt;br&gt;
    
    </summary>
    
      <category term="javaScript" scheme="http://kursaal.vip/categories/javaScript/"/>
    
    
      <category term="undefined" scheme="http://kursaal.vip/tags/undefined/"/>
    
      <category term="not defined" scheme="http://kursaal.vip/tags/not-defined/"/>
    
  </entry>
  
</feed>
