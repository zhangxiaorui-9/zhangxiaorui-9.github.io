<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>不万能的杂货铺</title>
  
  <subtitle>Record my life</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kursaal.vip/"/>
  <updated>2018-03-27T02:27:37.472Z</updated>
  <id>http://kursaal.vip/</id>
  
  <author>
    <name>About Mr</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>this is a test demo</title>
    <link href="http://kursaal.vip/2018/03/27/this-is-a-test-demo/"/>
    <id>http://kursaal.vip/2018/03/27/this-is-a-test-demo/</id>
    <published>2018-03-27T02:27:37.000Z</published>
    <updated>2018-03-27T02:27:37.472Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于Vue中的计算属性computed</title>
    <link href="http://kursaal.vip/2018/03/12/%E5%85%B3%E4%BA%8EVue%E4%B8%AD%E7%9A%84%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7computed/"/>
    <id>http://kursaal.vip/2018/03/12/关于Vue中的计算属性computed/</id>
    <published>2018-03-12T08:30:09.000Z</published>
    <updated>2018-03-15T03:29:52.643Z</updated>
    
    <content type="html"><![CDATA[<h4 id="为什么要使用计算属性（computed）"><a href="#为什么要使用计算属性（computed）" class="headerlink" title="为什么要使用计算属性（computed）"></a>为什么要使用计算属性（computed）</h4><p>我们都知道，在Vue中，对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。<br>看看代码:<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; number + 1 &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; ok ? &apos;YES&apos; : &apos;NO&apos; &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;div v-bind:id=&quot;&apos;list-&apos; + id&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含单个表达式，所以下面的例子都不会生效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 这是语句，不是表达式 --&gt;</span><br><span class="line"></span><br><span class="line">&#123;&#123; var a = 1 &#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;</span><br><span class="line"></span><br><span class="line">&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125;</span><br></pre></td></tr></table></figure><p>模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example&quot;&gt;</span><br><span class="line">  &#123;&#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>在这个地方，模板不再是简单的声明式逻辑。你必须看一段时间才能意识到，这里是想要显示变量 message 的翻转字符串。当你想要在模板中多次引用此处的翻转字符串时，就会更加难以处理。<br>所以，对于任何复杂逻辑，你都应当使用计算属性。一个简单的例子：<br>html：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example&quot;&gt;</span><br><span class="line">  &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>js：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#example&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &apos;Hello&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    // 计算属性的 getter</span><br><span class="line">    reversedMessage: function () &#123;</span><br><span class="line">      // `this` 指向 vm 实例</span><br><span class="line">      return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>结果：</p><blockquote><p>Original message: “Hello”<br>Computed reversed message: “olleH”</p></blockquote><p>这里我们声明了一个计算属性 <em>reversedMessage</em>。我们提供的函数将用作属性 vm.reversedMessage的 <em>getter</em> 函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(vm.reversedMessage) // =&gt; &apos;olleH&apos;</span><br><span class="line">vm.message = &apos;Goodbye&apos;</span><br><span class="line">console.log(vm.reversedMessage) // =&gt; &apos;eybdooG&apos;</span><br></pre></td></tr></table></figure><p>你可以打开浏览器的控制台，自行修改例子中的 vm。vm.reversedMessage 的值始终取决于 vm.message 的值。 </p><p>你可以像绑定普通属性一样在模板中绑定计算属性。Vue 知道 vm.reversedMessage 依赖于 vm.message，因此当 vm.message 发生改变时，所有依赖 vm.reversedMessage 的绑定也会更新。而且最妙的是我们已经以声明的方式创建了这种依赖关系：计算属性的 <em>getter</em> 函数是没有副作用 (side effect)的，这使它更易于测试和理解。</p><h4 id="计算属性-computed-与方法（methods）的区别"><a href="#计算属性-computed-与方法（methods）的区别" class="headerlink" title="计算属性(computed) 与方法（methods）的区别"></a>计算属性(computed) 与方法（methods）的区别</h4><p>你可能已经注意到我们可以通过在表达式中调用方法来达到同样的效果：</p><p>html：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Reversed message: &quot;&#123;&#123; reversedMessage() &#125;&#125;&quot;&lt;/p&gt;</span><br></pre></td></tr></table></figure></p><p>js：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 在组件中</span><br><span class="line">methods: &#123;</span><br><span class="line">  reversedMessage: function () &#123;</span><br><span class="line">    return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以将同一函数定义为一个方法（methods）而不是一个计算属性（computed）。两种方式的最终结果确实是完全相同的。然而， <strong>不同的是计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。</strong> 这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而<strong>不必再次</strong>执行函数。</p><p>这也同样意味着下面的计算属性将不再更新，因为 Date.now() 不是响应式依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  now: function () &#123;</span><br><span class="line">    return Date.now()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>相比之下，每当触发重新渲染时，调用方法（methods）将<strong>总会</strong>再次执行函数。</p><p>我们为什么需要缓存？假设我们有一个性能开销比较大的的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 <em>getter</em>！如果你不希望有缓存，请用方法（methods）来替代。  </p><h4 id="计算属性-computed-与侦听属性（watch）"><a href="#计算属性-computed-与侦听属性（watch）" class="headerlink" title="计算属性(computed)与侦听属性（watch）"></a>计算属性(computed)与侦听属性（watch）</h4><p>Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性（watch）。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch——特别是如果你之前使用过 AngularJS。然而，通常更好的做法是使用计算属性（computed）而不是命令式的 watch 回调。细想一下这个例子：</p><p>html：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;demo&quot;&gt;&#123;&#123; fullName &#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>js：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#demo&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: &apos;Foo&apos;,</span><br><span class="line">    lastName: &apos;Bar&apos;,</span><br><span class="line">    fullName: &apos;Foo Bar&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    firstName: function (val) &#123;</span><br><span class="line">      this.fullName = val + &apos; &apos; + this.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    lastName: function (val) &#123;</span><br><span class="line">      this.fullName = this.firstName + &apos; &apos; + val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>上面代码是命令式且重复的。将它与计算属性（computed）的版本进行比较：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#demo&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: &apos;Foo&apos;,</span><br><span class="line">    lastName: &apos;Bar&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    fullName: function () &#123;</span><br><span class="line">      return this.firstName + &apos; &apos; + this.lastName</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>是不是好了很多呢？</p><h4 id="计算属性的setter"><a href="#计算属性的setter" class="headerlink" title="计算属性的setter"></a>计算属性的setter</h4><p>计算属性默认只有 <em>getter</em> ，不过在需要时你也可以提供一个 <em>setter</em> ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    // getter</span><br><span class="line">    get: function () &#123;</span><br><span class="line">      return this.firstName + &apos; &apos; + this.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    // setter</span><br><span class="line">    set: function (newValue) &#123;</span><br><span class="line">      var names = newValue.split(&apos; &apos;)</span><br><span class="line">      this.firstName = names[0]</span><br><span class="line">      this.lastName = names[names.length - 1]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure></p><p>现在再运行 vm.fullName = ‘John Doe’ 时，<em>setter</em> 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">vue官网</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;为什么要使用计算属性（computed）&quot;&gt;&lt;a href=&quot;#为什么要使用计算属性（computed）&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用计算属性（computed）&quot;&gt;&lt;/a&gt;为什么要使用计算属性（computed）&lt;/h4&gt;&lt;p&gt;我们都知道，在Vue中，对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。&lt;br&gt;看看代码:&lt;br&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://kursaal.vip/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://kursaal.vip/tags/Vue/"/>
    
      <category term="computed" scheme="http://kursaal.vip/tags/computed/"/>
    
  </entry>
  
  <entry>
    <title>v-if和v-show的使用和区别</title>
    <link href="http://kursaal.vip/2018/02/23/v-if%E5%92%8Cv-show%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8C%BA%E5%88%AB/"/>
    <id>http://kursaal.vip/2018/02/23/v-if和v-show的使用和区别/</id>
    <published>2018-02-23T13:25:33.000Z</published>
    <updated>2018-03-15T05:41:01.910Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>专门记一篇关于vue条件渲染的文章似乎没有必要，刚开始也没打算记。但在应用过程中有时会有点迷惑，什么时候用v-if，什么时候用v-show，这两者有什么区别？所以，还是决定记一下，虽然大部分都是官网的介绍，但俗话说，眼过千变不如手过一遍。所以，记此篇。 </p></blockquote><a id="more"></a><h2 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h2><p>在字符串模板中，比如 Handlebars，我们得像这样写一个条件块：<br>html代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Handlebars 模板 --&gt;</span><br><span class="line">&#123;&#123;#if ok&#125;&#125;</span><br><span class="line">  &lt;h1&gt;Yes&lt;/h1&gt;</span><br><span class="line">&#123;&#123;/if&#125;&#125;</span><br></pre></td></tr></table></figure></p><p>在 Vue 中，我们使用 v-if 指令实现同样的功能：<br>html代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 v-if=&quot;ok&quot;&gt;Yes&lt;/h1&gt;</span><br></pre></td></tr></table></figure></p><p>也可以用 v-else 添加一个“else 块”：<br>html代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 v-if=&quot;ok&quot;&gt;Yes&lt;/h1&gt;</span><br><span class="line">&lt;h1 v-else&gt;No&lt;/h1&gt;</span><br></pre></td></tr></table></figure></p><h3 id="在-template-元素上使用-v-if-条件渲染分组"><a href="#在-template-元素上使用-v-if-条件渲染分组" class="headerlink" title="在 template 元素上使用 v-if 条件渲染分组"></a>在 template 元素上使用 v-if 条件渲染分组</h3><p>因为 v-if是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个 template 元素当做不可见的包裹元素，并在上面使用 v-if。最终的渲染结果将不包含 template 元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-if=&quot;ok&quot;&gt;</span><br><span class="line">  &lt;h1&gt;Title&lt;/h1&gt;</span><br><span class="line">  &lt;p&gt;Paragraph 1&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Paragraph 2&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h3 id="v-else"><a href="#v-else" class="headerlink" title="v-else"></a>v-else</h3><p>你可以使用 v-else 指令来表示 v-if 的“else 块”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-if=&quot;Math.random() &gt; 0.5&quot;&gt;</span><br><span class="line">  Now you see me</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div v-else&gt;</span><br><span class="line">  Now you don&apos;t</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>v-else 元素<strong>必须紧跟</strong>在带 v-if 或者 v-else-if 的元素的后面，否则它将不会被识别。</p><h3 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if"></a>v-else-if</h3><p>v-else-if，顾名思义，充当 v-if 的“else-if 块”，可以连续使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-if=&quot;type === &apos;A&apos;&quot;&gt;</span><br><span class="line">  A</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div v-else-if=&quot;type === &apos;B&apos;&quot;&gt;</span><br><span class="line">  B</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div v-else-if=&quot;type === &apos;C&apos;&quot;&gt;</span><br><span class="line">  C</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div v-else&gt;</span><br><span class="line">  Not A/B/C</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>类似于 v-else，v-else-if 也 <em>必须紧跟</em> 在带 v-if 或者 v-else-if 的元素之后!</p><h3 id="用-key-管理可复用的元素"><a href="#用-key-管理可复用的元素" class="headerlink" title="用 key 管理可复用的元素"></a>用 key 管理可复用的元素</h3><p>Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使Vue变得非常快之外，还有其它一些好处。例如，如果你允许用户在不同的登录方式之间切换：<br>html代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-if=&quot;loginType === &apos;username&apos;&quot;&gt;</span><br><span class="line">  &lt;label&gt;Username&lt;/label&gt;</span><br><span class="line">  &lt;input placeholder=&quot;Enter your username&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;template v-else&gt;</span><br><span class="line">  &lt;label&gt;Email&lt;/label&gt;</span><br><span class="line">  &lt;input placeholder=&quot;Enter your email address&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p><p>那么在上面的代码中切换 loginType <em>将不会清除</em>用户已经输入的内容。因为两个模板使用了相同的元素，input标签不会被替换掉——仅仅是替换了它的 placeholder。</p><p>这样也不总是符合实际需求，所以 Vue 为你提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 <em>key</em> 属性即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-if=&quot;loginType === &apos;username&apos;&quot;&gt;</span><br><span class="line">  &lt;label&gt;Username&lt;/label&gt;</span><br><span class="line">  &lt;input placeholder=&quot;Enter your username&quot; key=&quot;username-input&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;template v-else&gt;</span><br><span class="line">  &lt;label&gt;Email&lt;/label&gt;</span><br><span class="line">  &lt;input placeholder=&quot;Enter your email address&quot; key=&quot;email-input&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p><p>现在，每次切换时，输入框都将被重新渲染。  </p><p>注意，label元素仍然会被高效地复用，因为它们没有添加 key 属性。</p><h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h2><p>另一个用于根据条件展示元素的选项是 v-show 指令。用法大致一样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt;</span><br></pre></td></tr></table></figure></p><p>不同的是带有v-show的元素<strong>始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS 属性 display。</strong></p><p><strong>注意，v-show 不支持 template 元素，也不支持 v-else。</strong></p><h2 id="v-if-vs-v-show"><a href="#v-if-vs-v-show" class="headerlink" title="v-if vs v-show"></a>v-if vs v-show</h2><p>v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被<em>销毁和重建</em>。</p><p>v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p><p>相比之下，v-show 就简单得多——不管初始条件是什么，元素<em>总是会被渲染</em>，并且只是简单地基于 CSS 进行切换。</p><p>一般来说，<strong>v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销</strong>。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;专门记一篇关于vue条件渲染的文章似乎没有必要，刚开始也没打算记。但在应用过程中有时会有点迷惑，什么时候用v-if，什么时候用v-show，这两者有什么区别？所以，还是决定记一下，虽然大部分都是官网的介绍，但俗话说，眼过千变不如手过一遍。所以，记此篇。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://kursaal.vip/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://kursaal.vip/tags/Vue/"/>
    
      <category term="v-if" scheme="http://kursaal.vip/tags/v-if/"/>
    
      <category term="v-show" scheme="http://kursaal.vip/tags/v-show/"/>
    
  </entry>
  
  <entry>
    <title>jsonp解决跨域问题</title>
    <link href="http://kursaal.vip/2017/08/13/jsonp%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    <id>http://kursaal.vip/2017/08/13/jsonp解决跨域问题/</id>
    <published>2017-08-13T02:32:07.000Z</published>
    <updated>2018-03-15T03:33:20.463Z</updated>
    
    <content type="html"><![CDATA[<p>jsonp名字听上去挺高大上，实际只要理解了就是个矮穷矬。<br><a id="more"></a>  </p><h4 id="jsonp原理"><a href="#jsonp原理" class="headerlink" title="jsonp原理"></a>jsonp原理</h4><p>利用script标签没有跨域限制的“漏洞”，来达到与第三方通讯的目的。 </p><p>第三方产生的响应为json数据的包装（故称之为jsonp，即json padding）。  </p><p>它的基本思想是，网页通过添加一个script元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。  </p><p>首先，网页动态插入script元素，由它向跨源网址发出请求。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function addScriptTag(src) &#123;</span><br><span class="line">  var script = document.createElement(&apos;script&apos;);</span><br><span class="line">  script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);</span><br><span class="line">  script.src = src;</span><br><span class="line">  document.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">window.onload = function () &#123;</span><br><span class="line">  addScriptTag(&apos;http://example.com/ip?callback=foo&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function foo(data) &#123;</span><br><span class="line">  console.log(&apos;Your public IP address is: &apos; + data.ip);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码通过动态添加script元素，向服务器example.com发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于JSONP是必需的。<br>服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo(&#123;</span><br><span class="line">  &quot;ip&quot;: &quot;8.8.8.8&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>由于script元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用JSON.parse的步骤。</p><h4 id="面试中的问题"><a href="#面试中的问题" class="headerlink" title="面试中的问题"></a>面试中的问题</h4><ol><li>知道 jsonp么？<br>答：知道，可以实现跨域请求；<br>答不知道：换别的话题。</li><li>为什么 ajax 不可以，但是 jsonp 可以实现跨域请求呢？<br>答：因为 jsonp 是通过插入一个 script 标签，利用 script 可以跨域请求来实现的。换问题3；<br>答：面试官傻逼，ajax 现在也可以使用 cors 来做跨域请求；换问题 2.5。<br>答不知道：换问题 2.5。<br>2.5  jsonp实现原理？<br>答：通过创建一个 script 标签，将 src 设置为目标请求，插入到 dom 中，服务器接受该请求并返回数据，数据通常被包裹在回调钩子中；<br>回答不知道：我自己解释 jsonp 的实现。  </li><li>可以用 jsonp 发送 post 请求么？<br>答：显然不行，看过支持 post 请求的 script 么？<br>答不知道：反问，看过支持 post 请求的 script 么？  </li><li>参考 jsonp，还有那些发送跨域请求的途径？<br>答：img link iframe 等元素都可以发送跨域请求呀！<br>答不知道：反问img link iframe 等元素是不是也可以？</li></ol><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">浏览器同源政策及其规避方法</a><br><a href="https://www.zhihu.com/question/28890257/answer/269738446" target="_blank" rel="noopener">jsonp为什么不支持post请求，寸志的回答</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;jsonp名字听上去挺高大上，实际只要理解了就是个矮穷矬。&lt;br&gt;
    
    </summary>
    
      <category term="javaScript" scheme="http://kursaal.vip/categories/javaScript/"/>
    
    
      <category term="跨域" scheme="http://kursaal.vip/tags/%E8%B7%A8%E5%9F%9F/"/>
    
      <category term="jsonp" scheme="http://kursaal.vip/tags/jsonp/"/>
    
  </entry>
  
  <entry>
    <title>VSCode好用的插件</title>
    <link href="http://kursaal.vip/2017/06/26/VScode%E5%A5%BD%E7%94%A8%E7%9A%84%E6%8F%92%E4%BB%B6/"/>
    <id>http://kursaal.vip/2017/06/26/VScode好用的插件/</id>
    <published>2017-06-26T09:21:32.000Z</published>
    <updated>2018-03-26T09:32:06.393Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Open-In-Browser"><a href="#Open-In-Browser" class="headerlink" title="Open-In-Browser"></a>Open-In-Browser</h4><p>由于 VSCode 没有提供直接在浏览器中打开文件的内置界面，所以此插件在快捷菜单中添加了在默认浏览器查看文件选项，以及在客户端（Firefox，Chrome，IE）中打开命令面板选项。<br><a id="more"></a></p><h4 id="vscode-icon"><a href="#vscode-icon" class="headerlink" title="vscode-icon"></a>vscode-icon</h4><p>让  VSCode 资源树目录加上图标，必备良品！</p><h4 id="Path-Intellisense"><a href="#Path-Intellisense" class="headerlink" title="Path Intellisense"></a>Path Intellisense</h4><p>自动路劲补全，默认不带这个功能的</p><h4 id="beautify"><a href="#beautify" class="headerlink" title="beautify"></a>beautify</h4><p>Beautify css/sass/scss/less<br>react-beautify<br>格式化代码<br>使用指南：按F1,然后输入bea—&gt;选择你要格式的文件类型 js/css/html</p><h4 id="Bracket-Pair-Colorizer"><a href="#Bracket-Pair-Colorizer" class="headerlink" title="Bracket Pair Colorizer"></a>Bracket Pair Colorizer</h4><p>让括号拥有独立的颜色，易于区分。可以配合任意主题使用。</p><h4 id="Auto-Close-Tag"><a href="#Auto-Close-Tag" class="headerlink" title="Auto Close Tag"></a>Auto Close Tag</h4><p>自动闭合HTML标签</p><h4 id="Auto-rename-tag"><a href="#Auto-rename-tag" class="headerlink" title="Auto rename tag"></a>Auto rename tag</h4><p>更改HTML/XML标签名时，自动更新相对应的开始标签或结束标签的标签名</p><h4 id="Color-Info"><a href="#Color-Info" class="headerlink" title="Color Info"></a>Color Info</h4><p>这个便捷的插件，将为你提供你在 CSS 中使用颜色的相关信息。你只需在颜色上悬停光标，就可以预览色块中色彩模型的（HEX、 RGB、HSL 和 CMYK）相关信息了。</p><h4 id="HTML-Snippets"><a href="#HTML-Snippets" class="headerlink" title="HTML Snippets"></a>HTML Snippets</h4><p>超级实用且初级的 H5代码片段以及提示</p><h4 id="HTML-CSS-Support"><a href="#HTML-CSS-Support" class="headerlink" title="HTML CSS Support"></a>HTML CSS Support</h4><p>让 html 标签上写class 智能提示当前项目所支持的样式</p><h4 id="jQuery-Code-Snippets"><a href="#jQuery-Code-Snippets" class="headerlink" title="jQuery Code Snippets"></a>jQuery Code Snippets</h4><p>jquery 重度患者必须品，废话不多说，上图：<img src="https://note.youdao.com/yws/public/resource/9d45b53b6426be19db12b40358a60273/xmlnote/31F7EFF3ABCC4CE3B0FF04602443A190/2703" alt="image"></p><h4 id="HTMLHint"><a href="#HTMLHint" class="headerlink" title="HTMLHint"></a>HTMLHint</h4><p>html代码检测</p><h4 id="CSS-Peek"><a href="#CSS-Peek" class="headerlink" title="CSS Peek"></a>CSS Peek</h4><p>使用此插件，你可以追踪至样式表中 CSS 类和 ids 定义的地方。当你在 HTML 文件中右键单击选择器时，选择“ Go to Definition 和 Peek definition ”选项，它便会给你发送样式设置的 CSS 代码。</p><h4 id="vetur"><a href="#vetur" class="headerlink" title="vetur"></a>vetur</h4><p>VUE —— 语法高亮、智能感知、Emmet等</p><h4 id="VueHelper"><a href="#VueHelper" class="headerlink" title="VueHelper"></a>VueHelper</h4><p>VUE —— snippet代码片段</p><h4 id="filesize"><a href="#filesize" class="headerlink" title="filesize"></a>filesize</h4><p>会在左下角显示文件大小，很不错</p><h4 id="Debugger-for-Chrome"><a href="#Debugger-for-Chrome" class="headerlink" title="Debugger for Chrome"></a>Debugger for Chrome</h4><h4 id="Preview"><a href="#Preview" class="headerlink" title="Preview"></a>Preview</h4><p>按F1,输入open preview to the side</p><h4 id="设置自动换行"><a href="#设置自动换行" class="headerlink" title="设置自动换行"></a>设置自动换行</h4><p>设置 – 用户设置 – 添加”editor.wordWrap”: “on” </p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Open-In-Browser&quot;&gt;&lt;a href=&quot;#Open-In-Browser&quot; class=&quot;headerlink&quot; title=&quot;Open-In-Browser&quot;&gt;&lt;/a&gt;Open-In-Browser&lt;/h4&gt;&lt;p&gt;由于 VSCode 没有提供直接在浏览器中打开文件的内置界面，所以此插件在快捷菜单中添加了在默认浏览器查看文件选项，以及在客户端（Firefox，Chrome，IE）中打开命令面板选项。&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="http://kursaal.vip/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="VSCode插件" scheme="http://kursaal.vip/tags/VSCode%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>关于函数重载和arguments</title>
    <link href="http://kursaal.vip/2017/03/24/%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E5%92%8Carguments/"/>
    <id>http://kursaal.vip/2017/03/24/关于函数重载和arguments/</id>
    <published>2017-03-24T11:12:35.000Z</published>
    <updated>2018-03-15T03:32:37.612Z</updated>
    
    <content type="html"><![CDATA[<h4 id="重载的概念"><a href="#重载的概念" class="headerlink" title="重载的概念"></a>重载的概念</h4><p>重载，简单说，就是函数或者方法有相同的名称，但是参数列表(包括参数个数和参数类型)不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。<br><a id="more"></a></p><h4 id="js中的函数重载"><a href="#js中的函数重载" class="headerlink" title="js中的函数重载"></a>js中的函数重载</h4><p>js中没有重载。就是说，js不允许有名字相同的函数，如果你声明了两个名字相同的函数，后一个就会覆盖掉前一个。<br>在js中，函数是作为一种特殊对象类型存在的，函数的名字只是一个普通的变量，本质与var a = 1中的变量a没什么区别。所以如果你先后定义了两个同名函数，实际上相当于先后将两个函数对象绑定到了同一个变量上，所以后者必然覆盖前者，不会共存，也自然不存在重载了。</p><h4 id="js中的arguments"><a href="#js中的arguments" class="headerlink" title="js中的arguments"></a>js中的arguments</h4><p>总所周知，js是一门相当灵活的语言。当我们在js中在调用一个函数的时候，我们经常会给这个函数传递一些参数，js把传入到这个函数的全部参数存储在一个叫做arguments的东西里面，那么这到底是什么东西？<br>在js中万物皆对象，甚至数组字符串函数都是对象。所以这个叫做arguments的东西也是个对象，而且是一个特殊的对象，它的属性名是按照传入参数的序列来的，第1个参数的属性名是’0’，第2个参数的属性名是’1’，以此类推，并且它还有length属性，存储的是当前传入函数参数的个数，很多时候我们把这种对象叫做类数组对象。关于类数组，此处不做详细讲解。<br>接下来我们来看看arguments对象里面到底有些什么东西，是骡子是马拉出来溜溜。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function showargs() &#123;</span><br><span class="line">    console.log( arguments );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showargs(1,2,3,4,5);</span><br></pre></td></tr></table></figure><p>打印结果：<br><img src="http://img.blog.csdn.net/20161119152524405" alt="image">  </p><p>这里我们可以看到arguments对象将我传入的五个参数以数组的形式保存在里面，还保存了我传入函数的实参的个数（length）。而且我们可以看到arguments对象的 <em> proto </em>是指向object的，这也说明了他是个类数组对象，而不是一个数组。<br>有了这个对象我们以后写函数的时候，就不用给所有的形参指定参数名，然后通过参数名的方式获取参数了，我们可以直接使用arguments对象来获取实参，这样是不是方便了很多呢。<br>有些语言在我们给函数指定了参数名之后，当调用函数时，会判断当前传入的参数是否与函数定义的参数个数相等，不相等就会报错。但是灵活的js并不会验证传递给函数的参数个数是否等于函数定义的参数个数。所以代码的简洁度（为了装逼），我们使用arguments调用参数可以不混淆不同函数之间的参数名。另外代码的严整度（为了装逼），我们也能用arguments来判断当前传入参数的个数是否与我们需要的数量一致。<br>下面举个栗子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function add() &#123;</span><br><span class="line">    if( arguments.length == 2 )&#123;</span><br><span class="line">        return arguments[0] + arguments[1];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return &apos;传入参数不合法&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log( add(2,3) );</span><br><span class="line">console.log( add(1,2,3) );</span><br></pre></td></tr></table></figure></p><p>看看结果：<br><img src="http://img.blog.csdn.net/20161119154939672" alt="image"><br>最后我们还可以看到arguments还有一个叫做callee的属性，这个属性是表示的是当前函数的一个引用。简单点说，这个属性里面存储的是我们调用的这个函数的代码，实在无法理解的时候，又到了console.log大显身手的时候了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function showcallee() &#123;</span><br><span class="line">    var a = &apos;这里是代码&apos;;</span><br><span class="line">    var b = &apos;这是另一段代码&apos;;</span><br><span class="line">    var c = a + b;</span><br><span class="line">    console.log(arguments.callee);</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line">showcallee();</span><br></pre></td></tr></table></figure></p><p>看看结果：<br><img src="http://img.blog.csdn.net/20161119161029575" alt="image"><br>看到结果的你是不是和我一样惊呆了呢，这不就是我写的代码吗？arguments.callee完完整整的把这个函数的这段代码返回了。 </p><h4 id="arguments和函数重载的关系"><a href="#arguments和函数重载的关系" class="headerlink" title="arguments和函数重载的关系"></a>arguments和函数重载的关系</h4><p>上面说过了，由于js是一种弱类型的语言，没有重载机制，当我们重写函数时，会将原来的函数直接覆盖，这里我们能利用arguments，来判断传入的实参类型与数量进行不同的操作，然后返回不同的结果，来实现js中的函数重载。<br>举个栗子：<br>下面我们利用arguments对象来实现一个参数相加的函数，不论传入多少参数都行，将传入的参数相加后返回。 </p><pre><code>function add() {    var len = arguments.length,        sum = 0;    for(;len--;){        sum += arguments[len];    }    return sum;}console.log( add(1,2,3) );   //6console.log( add(1,3) );     //4console.log( add(1,2,3,5,6,2,7) );   //26</code></pre><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="http://blog.csdn.net/qq_16339527/article/details/53231725" target="_blank" rel="noopener">js的arguments到底是什么？</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;重载的概念&quot;&gt;&lt;a href=&quot;#重载的概念&quot; class=&quot;headerlink&quot; title=&quot;重载的概念&quot;&gt;&lt;/a&gt;重载的概念&lt;/h4&gt;&lt;p&gt;重载，简单说，就是函数或者方法有相同的名称，但是参数列表(包括参数个数和参数类型)不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。&lt;br&gt;
    
    </summary>
    
      <category term="javaScript" scheme="http://kursaal.vip/categories/javaScript/"/>
    
    
      <category term="arguments" scheme="http://kursaal.vip/tags/arguments/"/>
    
      <category term="函数重载" scheme="http://kursaal.vip/tags/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>javaScript中this的用法</title>
    <link href="http://kursaal.vip/2017/03/11/this%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>http://kursaal.vip/2017/03/11/this的用法/</id>
    <published>2017-03-11T07:22:16.000Z</published>
    <updated>2018-03-15T03:32:32.339Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><blockquote><p>this是JavaScript中一个比较难理解的点，很多新人会很迷惑。本文非原创，是阮一峰老师个人博客里的，个人感觉理解起来会很容易。拿来与大家分享。<a href="http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html" target="_blank" rel="noopener">原文链接</a></p></blockquote><a id="more"></a><h4 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h4><p>this是Javascript语言的一个关键字。</p><p>它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。比如，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　function test()&#123;</span><br><span class="line"></span><br><span class="line">　　　　this.x = 1;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><p>随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，==调用函数的那个对象。==</p><hr><p>下面分四种情况，详细讨论this的用法。  </p><h5 id="情况一：纯粹的函数调用"><a href="#情况一：纯粹的函数调用" class="headerlink" title="情况一：纯粹的函数调用"></a>情况一：纯粹的函数调用</h5><p>这是函数的最通常用法，属于全局性调用，因此this就代表全局对象Global。</p><p>请看下面这段代码，它的运行结果是1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">　function test()&#123;</span><br><span class="line"></span><br><span class="line">　　　　this.x = 1;</span><br><span class="line"></span><br><span class="line">　　　　alert(this.x);</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　test(); // 1</span><br></pre></td></tr></table></figure></p><p>为了证明this就是全局对象，我对代码做一些改变：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">　　var x = 1;</span><br><span class="line"></span><br><span class="line">　　function test()&#123;</span><br><span class="line"></span><br><span class="line">　　　　alert(this.x);</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　test(); // 1</span><br></pre></td></tr></table></figure></p><p>运行结果还是1。再变一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">　var x = 1;</span><br><span class="line"></span><br><span class="line">　　function test()&#123;</span><br><span class="line"></span><br><span class="line">　　　　this.x = 0;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　test();</span><br><span class="line"></span><br><span class="line">　　alert(x); //0</span><br></pre></td></tr></table></figure><h5 id="情况二：作为对象方法的调用"><a href="#情况二：作为对象方法的调用" class="headerlink" title="情况二：作为对象方法的调用"></a>情况二：作为对象方法的调用</h5><p>函数还可以作为某个对象的方法调用，这时this就指这个上级对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">　function test()&#123;</span><br><span class="line"></span><br><span class="line">　　　　alert(this.x);</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　var o = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">　　o.x = 1;</span><br><span class="line"></span><br><span class="line">　　o.m = test;</span><br><span class="line"></span><br><span class="line">　　o.m(); // 1</span><br></pre></td></tr></table></figure><h5 id="情况三-：作为构造函数调用"><a href="#情况三-：作为构造函数调用" class="headerlink" title="情况三 ：作为构造函数调用"></a>情况三 ：作为构造函数调用</h5><p>所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this就指这个新对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">　function test()&#123;</span><br><span class="line"></span><br><span class="line">　　　　this.x = 1;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　var o = new test();</span><br><span class="line"></span><br><span class="line">　　alert(o.x); // 1</span><br></pre></td></tr></table></figure></p><p>运行结果为1。为了表明这时this不是全局对象，我对代码做一些改变：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">　　var x = 2;</span><br><span class="line"></span><br><span class="line">　　function test()&#123;</span><br><span class="line"></span><br><span class="line">　　　　this.x = 1;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　var o = new test();</span><br><span class="line"></span><br><span class="line">　　alert(x); //2</span><br></pre></td></tr></table></figure></p><p>运行结果为2，表明全局变量x的值根本没变。  </p><h5 id="情况四：-apply调用"><a href="#情况四：-apply调用" class="headerlink" title="情况四： apply调用"></a>情况四： apply调用</h5><p>apply()是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。因此，this指的就是这第一个参数。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">　　var x = 0;</span><br><span class="line"></span><br><span class="line">　　function test()&#123;</span><br><span class="line"></span><br><span class="line">　　　　alert(this.x);</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　var o=&#123;&#125;;</span><br><span class="line"></span><br><span class="line">　　o.x = 1;</span><br><span class="line"></span><br><span class="line">　　o.m = test;</span><br><span class="line"></span><br><span class="line">　　o.m.apply(); //0</span><br></pre></td></tr></table></figure><p>apply()的参数为空时，默认调用全局对象。因此，这时的运行结果为0，证明this指的是全局对象。</p><p>如果把最后一行代码修改为 : </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　o.m.apply(o); //1</span><br></pre></td></tr></table></figure><p>运行结果就变成了1，证明了这时this代表的是对象o。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;this是JavaScript中一个比较难理解的点，很多新人会很迷惑。本文非原创，是阮一峰老师个人博客里的，个人感觉理解起来会很容易。拿来与大家分享。&lt;a href=&quot;http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="javaScript" scheme="http://kursaal.vip/categories/javaScript/"/>
    
    
      <category term="this" scheme="http://kursaal.vip/tags/this/"/>
    
      <category term="js" scheme="http://kursaal.vip/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>not defined、undefined和null的区别</title>
    <link href="http://kursaal.vip/2017/02/24/not-defined%E3%80%81undefined%E5%92%8Cnull%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://kursaal.vip/2017/02/24/not-defined、undefined和null的区别/</id>
    <published>2017-02-24T06:11:40.000Z</published>
    <updated>2018-03-15T03:33:06.034Z</updated>
    
    <content type="html"><![CDATA[<h5 id="not-defined"><a href="#not-defined" class="headerlink" title="not defined"></a>not defined</h5><p>意为没有定义的变量。<br>例：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">console.log(m);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>上述代码中m没有被定义，此时浏览器会报错</p><blockquote><p>Uncaught ReferenceError: m is not defined  </p></blockquote><h5 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h5><p>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：  </p><ol><li>变量被声明了，但没有赋值时，就等于undefined。</li><li>调用函数时，应该提供的参数没有提供，该参数等于undefined。</li><li>对象没有赋值的属性，该属性的值为undefined。</li><li>函数没有返回值时，默认返回undefined。  </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var i;</span><br><span class="line">i // undefined</span><br><span class="line"></span><br><span class="line">function f(x)&#123;console.log(x)&#125;</span><br><span class="line">f() // undefined</span><br><span class="line"></span><br><span class="line">var  o = new Object();</span><br><span class="line">o.p // undefined</span><br><span class="line"></span><br><span class="line">var x = f();</span><br><span class="line">x // undefined</span><br></pre></td></tr></table></figure><p>上面四种情况执行结果一样：不会报错，会打印出undefined。  </p><h5 id="null"><a href="#null" class="headerlink" title="null"></a>null</h5><p>null表示 “没有对象”，即该处不应该有值。典型用法是：  </p><ol><li>作为函数的参数，表示该函数的参数不是对象。</li><li>作为对象原型链的终点。  </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.getPrototypeOf(Object.prototype)</span><br><span class="line">// null</span><br></pre></td></tr></table></figure><h5 id="需要注意"><a href="#需要注意" class="headerlink" title="需要注意"></a>需要注意</h5><p>这里需要注意的是：null == undefined结果是true的，null === undefined结果是false的。  </p><h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p><a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html" target="_blank" rel="noopener">阮一峰：undefined与null的区别</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;not-defined&quot;&gt;&lt;a href=&quot;#not-defined&quot; class=&quot;headerlink&quot; title=&quot;not defined&quot;&gt;&lt;/a&gt;not defined&lt;/h5&gt;&lt;p&gt;意为没有定义的变量。&lt;br&gt;例：&lt;br&gt;
    
    </summary>
    
      <category term="javaScript" scheme="http://kursaal.vip/categories/javaScript/"/>
    
    
      <category term="undefined" scheme="http://kursaal.vip/tags/undefined/"/>
    
      <category term="not defined" scheme="http://kursaal.vip/tags/not-defined/"/>
    
  </entry>
  
  <entry>
    <title>关于盒模型的理解</title>
    <link href="http://kursaal.vip/2017/01/16/%E5%85%B3%E4%BA%8E%E7%9B%92%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://kursaal.vip/2017/01/16/关于盒模型的理解/</id>
    <published>2017-01-16T11:17:22.000Z</published>
    <updated>2018-03-16T06:32:59.326Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>盒子是无处不在的。html任何一个元素都可以看作一个盒子，这个盒子不可见，但是它存在于页面的每个角落。</p></blockquote><a id="more"></a><h2 id="盒子模型简介"><a href="#盒子模型简介" class="headerlink" title="盒子模型简介"></a>盒子模型简介</h2><p>一个盒子包括了content（实际内容）、border（边框）、padding（内边距）和margin（外边距）。下图为一个盒子模型图：<img src="https://upload-images.jianshu.io/upload_images/4792860-4c293beaf206f605.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/557" alt="image"></p><h3 id="content（内容）"><a href="#content（内容）" class="headerlink" title="content（内容）"></a>content（内容）</h3><p>盒子的内容，显示文本和图像。我们给元素设置的width和height其实是content的宽高，</p><p>如果指定高度大于显示内容所需高度，多余的高度会产生类似内边距一样的效果；如果指定高度小于显示内容所需高度，会出现滚动条。如果元素内容的高度大于元素框的高度，浏览器的具体行为取决于overflow属性。</p><h3 id="border（边框）"><a href="#border（边框）" class="headerlink" title="border（边框）"></a>border（边框）</h3><p>元素的边框是围绕元素内容的内边距的一条或多条线。边框由粗细、样式和颜色三部分组成。</p><h3 id="padding（内边距）"><a href="#padding（内边距）" class="headerlink" title="padding（内边距）"></a>padding（内边距）</h3><p>清除内容周围的区域，内边距是透明的，取值不能为负，受盒子的Background属性影响，padding是有背景的。</p><h3 id="margin（外边距）"><a href="#margin（外边距）" class="headerlink" title="margin（外边距）"></a>margin（外边距）</h3><p>在元素外创建额外的空白，空白通常指不能放其他元素的区域，而且在这个区域中可以看到父元素的背景（padding所带的是本身的背景而非父元素）。margin经常取负值实现定位的作用。</p><p>外边距有一个合并问题，经常使人们混淆，简单来说，外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。</p><h2 id="两种盒子模型"><a href="#两种盒子模型" class="headerlink" title="两种盒子模型"></a>两种盒子模型</h2><p>其实盒模型有两种，分别是<strong>ie盒子模型</strong>（IE6以下版本浏览器)和<strong>标准w3c盒子模型</strong>，区别在于前者content的宽度和高度包括了border和padding。</p><p>margin（外边界）虽不可见，但是它确实在文档中占据了空间，我们要区分两个概念即：盒子所占空间（计入margin ）和盒子实际的大小（不计入margin） 。</p><h3 id="实例区分两种盒模型"><a href="#实例区分两种盒模型" class="headerlink" title="实例区分两种盒模型"></a>实例区分两种盒模型</h3><p>举个例子来区分两种盒模型：一个盒子的 margin 为 20px，border 为 2px，padding 为 10px，content 的宽为 200px、高为 50px。</p><ul><li>在ie盒子模型中：</li></ul><ol><li>盒子所占空间：width=20ｘ2+200=240；height=20ｘ2+50=90</li><li>盒子实际大小：width=200；height=50</li></ol><ul><li>在标准w3c盒子模型中：</li></ul><ol><li>盒子所占空间：width=20ｘ2+2ｘ2+10ｘ2+200=264；height=20ｘ2+２ｘ2+10ｘ2 +50=114</li><li>盒子实际大小：width=200 +2ｘ2+10ｘ2=224；height=50+2ｘ2+10ｘ2=74  </li></ol><p>解释到这里，有的人可能会想起CSS3里面有个叫做box-sizing的属性，咦？两个盒模型不就是它不同取值下的效果吗？</p><h2 id="box-sizing和两种盒模型不得不说的事"><a href="#box-sizing和两种盒模型不得不说的事" class="headerlink" title="box-sizing和两种盒模型不得不说的事"></a>box-sizing和两种盒模型不得不说的事</h2><p>box-sizing有三个取值：</p><ol><li><p>content-box:使元素遵循标准 w3c 盒子模型（默认值）。</p></li><li><p>border-box:使元素遵循ie 盒子模型。</p></li><li><p>inherit： 规定应从父元素继承 box-sizing 属性的值。  </p></li></ol><p>当你遵循ie盒子模型(box-sizing取值为border-box)时，不管你如何设置padding和border（小于width/2），它只在盒子里面伸缩，不影响整体的宽高，这个border-box是不是在某些时候非常好用？但也不能盲目地用，因为它会影响content，如果padding和border太大，会把内容挤掉的。  </p><p>现在还在用IE6以下的浏览器的用户已经很少了，所以目前浏览器大部分元素都是基于W3C标准盒子模型 上。所以我们平常说的盒子模型一般就是标准w3c盒子模型（但对于input、button元素默认border-box，还是基于传统的ie 盒子模型）。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/2353c364318b" target="_blank" rel="noopener">谈谈我对盒模型的理解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;盒子是无处不在的。html任何一个元素都可以看作一个盒子，这个盒子不可见，但是它存在于页面的每个角落。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="css" scheme="http://kursaal.vip/categories/css/"/>
    
    
      <category term="css" scheme="http://kursaal.vip/tags/css/"/>
    
      <category term="盒模型" scheme="http://kursaal.vip/tags/%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>jQuery中的事件委托</title>
    <link href="http://kursaal.vip/2016/12/23/jQuery%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/"/>
    <id>http://kursaal.vip/2016/12/23/jQuery中的事件委托/</id>
    <published>2016-12-23T10:11:09.000Z</published>
    <updated>2018-03-23T10:26:29.601Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事件绑定的两种方式"><a href="#事件绑定的两种方式" class="headerlink" title="事件绑定的两种方式"></a>事件绑定的两种方式</h2><p>以click事件为例：<br><a id="more"></a> </p><ol><li><p>普通绑定事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;.btn1&apos;).click(function()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>on绑定事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(document).on(&apos;click&apos;,&apos;.btn2&apos;,function()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h2 id="两种绑定方式的区别"><a href="#两种绑定方式的区别" class="headerlink" title="两种绑定方式的区别"></a>两种绑定方式的区别</h2><ol><li>click事件是在页面加载后，获取的所有类名为btn1的元素，然后绑定了这个click事件，要是通过其他操作再生成一个btn1元素，它就没有click这个事件；</li><li>而on()事件起到了监听的效果,可以实现动态html元素绑定，比如一开始只有一个btn2元素，通过某种方法又加了一个btn2元素，这个元素也可以点击，可以无限添加btn2。  </li></ol><p>举个栗子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;我是第一个&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;我是第二个&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;button&gt;添加&lt;/button&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;button&apos;).click(function()&#123;</span><br><span class="line">    $(&apos;ul&apos;).append($(&apos;&lt;li&gt;我是被添加的&lt;/li&gt;&apos;));</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过点击’添加’按钮，我们在ul里动态添加了一个li，此时，通过click方式，新增加的li是没有点击事件的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;li&apos;).click(function()&#123;</span><br><span class="line">    console.log($(this).text());</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>而通过on方式给ul添加，我们后来添加的li也是有点击事件的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;ul&apos;).on(&apos;click&apos;,&apos;li&apos;,function()&#123;</span><br><span class="line">    console.log($(this).text());</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="事件委托原理"><a href="#事件委托原理" class="headerlink" title="事件委托原理"></a>事件委托原理</h2><p>那么怎么实现这个动态监听的过程呢？<br>on()事件相当于是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;ul&apos;).click(function()&#123;</span><br><span class="line">    if(点击的是li)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>给ul添加了一个click事件，当点击的是li，事件冒泡原理，从里到外，就相当于点击了ul，那么就会执行后面的操作，本质上只给ul添加了一个事件。</p><h2 id="事件委托的好处"><a href="#事件委托的好处" class="headerlink" title="事件委托的好处"></a>事件委托的好处</h2><ol><li>原来的事件绑定，相当于给所有的li都要绑定事件，现在只需要给ul一个元素绑定事件，大大提高了效率和页面性能</li><li>解决了动态添加的元素不能触发事件的问题。</li></ol><p>注意：jQuery1.7+开始支持</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/wufangfang/p/5333007.html" target="_blank" rel="noopener">jQuery里面的普通绑定事件和on委托事件</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;事件绑定的两种方式&quot;&gt;&lt;a href=&quot;#事件绑定的两种方式&quot; class=&quot;headerlink&quot; title=&quot;事件绑定的两种方式&quot;&gt;&lt;/a&gt;事件绑定的两种方式&lt;/h2&gt;&lt;p&gt;以click事件为例：&lt;br&gt;
    
    </summary>
    
      <category term="jQuery" scheme="http://kursaal.vip/categories/jQuery/"/>
    
    
      <category term="事件委托" scheme="http://kursaal.vip/tags/%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/"/>
    
  </entry>
  
</feed>
